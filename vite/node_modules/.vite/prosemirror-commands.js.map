{
  "version": 3,
  "sources": ["../../../node_modules/prosemirror-commands/src/commands.js"],
  "sourcesContent": ["import {joinPoint, canJoin, findWrapping, liftTarget, canSplit, ReplaceAroundStep} from \"prosemirror-transform\"\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Selection, TextSelection, NodeSelection, AllSelection} from \"prosemirror-state\"\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Delete the selection, if there is one.\nexport function deleteSelection(state, dispatch) {\n  if (state.selection.empty) return false\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it\u2014if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nexport function joinBackward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    return false\n\n  let $cut = findCutBefore($cursor)\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    let range = $cursor.blockRange(), target = range && liftTarget(range)\n    if (target == null) return false\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  let before = $cut.nodeBefore\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    return true\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    if (dispatch) {\n      let tr = state.tr.deleteRange($cursor.before(), $cursor.after())\n      tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                      : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize))\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild))\n    if (node.isTextblock) return true\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nexport function selectNodeBackward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false\n    $cut = findCutBefore($head)\n  }\n  let node = $cut && $cut.nodeBefore\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView())\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1))\n    if ($pos.node(i).type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nexport function joinForward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    return false\n\n  let $cut = findCutAfter($cursor)\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) return false\n\n  let after = $cut.nodeAfter\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) return true\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    if (dispatch) {\n      let tr = state.tr.deleteRange($cursor.before(), $cursor.after())\n      tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                      : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)))\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nexport function selectNodeForward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      return false\n    $cut = findCutAfter($head)\n  }\n  let node = $cut && $cut.nodeAfter\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView())\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    let parent = $pos.node(i)\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1))\n    if (parent.type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nexport function joinUp(state, dispatch) {\n  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false\n    point = sel.from\n  } else {\n    point = joinPoint(state.doc, sel.from, -1)\n    if (point == null) return false\n  }\n  if (dispatch) {\n    let tr = state.tr.join(point)\n    if (nodeSel) tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nexport function joinDown(state, dispatch) {\n  let sel = state.selection, point\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false\n    point = sel.to\n  } else {\n    point = joinPoint(state.doc, sel.to, 1)\n    if (point == null) return false\n  }\n  if (dispatch)\n    dispatch(state.tr.join(point).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nexport function lift(state, dispatch) {\n  let {$from, $to} = state.selection\n  let range = $from.blockRange($to), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nexport function newlineInCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView())\n  return true\n}\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i++) {\n    let {type} = match.edge(i)\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nexport function exitCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after))\n  if (!above.canReplaceWith(after, after, type)) return false\n  if (dispatch) {\n    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill())\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nexport function createParagraphNear(state, dispatch) {\n  let sel = state.selection, {$from, $to} = sel\n  if (!(sel instanceof NodeSelection) || $from.parent.inlineContent) return false\n  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()))\n  if (!type || !type.isTextblock) return false\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos\n    let tr = state.tr.insert(side, type.createAndFill())\n    tr.setSelection(TextSelection.create(tr.doc, side + 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nexport function liftEmptyBlock(state, dispatch) {\n  let {$cursor} = state.selection\n  if (!$cursor || $cursor.parent.content.size) return false\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before()\n    if (canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView())\n      return true\n    }\n  }\n  let range = $cursor.blockRange(), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nexport function splitBlock(state, dispatch) {\n  let {$from, $to} = state.selection\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) return false\n    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView())\n    return true\n  }\n\n  if (!$from.parent.isBlock) return false\n\n  if (dispatch) {\n    let atEnd = $to.parentOffset == $to.parent.content.size\n    let tr = state.tr\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) tr.deleteSelection()\n    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n    let types = atEnd && deflt ? [{type: deflt}] : null\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}]\n      can = true\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt &&\n          $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from([deflt.create(), $from.parent])))\n        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n    }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nexport function splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (tr => {\n    let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n    if (marks) tr.ensureMarks(marks)\n    dispatch(tr)\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nexport function selectParentNode(state, dispatch) {\n  let {$from, to} = state.selection, pos\n  let same = $from.sharedDepth(to)\n  if (same == 0) return false\n  pos = $from.before(same)\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)))\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Select the whole document.\nexport function selectAll(state, dispatch) {\n  if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)))\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index()\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView())\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    return false\n  if (dispatch)\n    dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView())\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match\n  if (before.type.spec.isolating || after.type.spec.isolating) return false\n  if (joinMaybeClear(state, $cut, dispatch)) return true\n\n  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1)\n  if (canDelAfter &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize, wrap = Fragment.empty\n      for (let i = conn.length - 1; i >= 0; i--)\n        wrap = Fragment.from(conn[i].create(null, wrap))\n      wrap = Fragment.from(before.copy(wrap))\n      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true))\n      let joinAt = end + 2 * conn.length\n      if (canJoin(tr.doc, joinAt)) tr.join(joinAt)\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  let selAfter = Selection.findFrom($cut, 1)\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range)\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  if (canDelAfter && after.isTextblock && textblockAt(before, \"end\")) {\n    let at = before, wrap = []\n    for (;;) {\n      wrap.push(at)\n      if (at.isTextblock) break\n      at = at.lastChild\n    }\n    if (at.canReplace(at.childCount, at.childCount, after.content)) {\n      if (dispatch) {\n        let end = Fragment.empty\n        for (let i = wrap.length - 1; i >= 0; i--) end = Fragment.from(wrap[i].copy(end))\n        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize,\n                                                     $cut.pos + 1, $cut.pos + after.nodeSize - 1,\n                                                     new Slice(end, wrap.length, 0), 0, true))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  return false\n}\n\n// Parameterized commands\n\n// :: (NodeType, ?Object) \u2192 (state: EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nexport function wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return false\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType, ?Object) \u2192 (state: EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nexport function setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {from, to} = state.selection\n    let applicable = false\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (applicable) return false\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return\n      if (node.type == nodeType) {\n        applicable = true\n      } else {\n        let $pos = state.doc.resolve(pos), index = $pos.index()\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType)\n      }\n    })\n    if (!applicable) return false\n    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView())\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  for (let i = 0; i < ranges.length; i++) {\n    let {$from, $to} = ranges[i]\n    let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (can) return false\n      can = node.inlineContent && node.type.allowsMarkType(type)\n    })\n    if (can) return true\n  }\n  return false\n}\n\n// :: (MarkType, ?Object) \u2192 (state: EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nexport function toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    let {empty, $cursor, ranges} = state.selection\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          dispatch(state.tr.removeStoredMark(markType))\n        else\n          dispatch(state.tr.addStoredMark(markType.create(attrs)))\n      } else {\n        let has = false, tr = state.tr\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType)\n        }\n        for (let i = 0; i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          if (has) {\n            tr.removeMark($from.pos, $to.pos, markType)\n          } else {\n            let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore\n            let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0\n            let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0\n            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd }\n            tr.addMark(from, to, markType.create(attrs))\n          }\n        }\n        dispatch(tr.scrollIntoView())\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return tr => {\n    if (!tr.isGeneric) return dispatch(tr)\n\n    let ranges = []\n    for (let i = 0; i < tr.mapping.maps.length; i++) {\n      let map = tr.mapping.maps[i]\n      for (let j = 0; j < ranges.length; j++)\n        ranges[j] = map.map(ranges[j])\n      map.forEach((_s, _e, from, to) => ranges.push(from, to))\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    let joinable = []\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from = ranges[i], to = ranges[i + 1]\n      let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth)\n      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        let after = parent.maybeChild(index)\n        if (!after) break\n        if (index && joinable.indexOf(pos) == -1) {\n          let before = parent.child(index - 1)\n          if (before.type == after.type && isJoinable(before, after))\n            joinable.push(pos)\n        }\n        pos += after.nodeSize\n      }\n    }\n    // Join the joinable points\n    joinable.sort((a, b) => a - b)\n    for (let i = joinable.length - 1; i >= 0; i--) {\n      if (canJoin(tr.doc, joinable[i])) tr.join(joinable[i])\n    }\n    dispatch(tr)\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) \u2192 bool, union<(before: Node, after: Node) \u2192 bool, [string]>) \u2192 (state: EditorState, ?(tr: Transaction)) \u2192 bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nexport function autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    let types = isJoinable\n    isJoinable = node => types.indexOf(node.type.name) > -1\n  }\n  return (state, dispatch) => command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable))\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool]) \u2192 (EditorState, ?(tr: Transaction), ?EditorView) \u2192 bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nexport function chainCommands(...commands) {\n  return function(state, dispatch, view) {\n    for (let i = 0; i < commands.length; i++)\n      if (commands[i](state, dispatch, view)) return true\n    return false\n  }\n}\n\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward)\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward)\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nexport let pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nexport let macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"]\n}\nfor (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key]\n\n// declare global: os, navigator\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nexport let baseKeymap = mac ? macBaseKeymap : pcBaseKeymap\n"],
  "mappings": "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",
  "names": []
}
