{
  "version": 3,
  "sources": ["../../../node_modules/prosemirror-transform/src/map.js", "../../../node_modules/prosemirror-transform/src/transform.js", "../../../node_modules/prosemirror-transform/src/step.js", "../../../node_modules/prosemirror-transform/src/replace_step.js", "../../../node_modules/prosemirror-transform/src/structure.js", "../../../node_modules/prosemirror-transform/src/mark_step.js", "../../../node_modules/prosemirror-transform/src/mark.js", "../../../node_modules/prosemirror-transform/src/replace.js"],
  "sourcesContent": ["// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) \u2192 number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) \u2192 MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nconst lower16 = 0xffff\nconst factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nexport class MapResult {\n  constructor(pos, deleted = false, recover = null) {\n    // :: number The mapped version of the position.\n    this.pos = pos\n    // :: bool Tells you whether the position was deleted, that is,\n    // whether the step removed its surroundings from the document.\n    this.deleted = deleted\n    this.recover = recover\n  }\n}\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nexport class StepMap {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents a modified chunk as `[start, oldSize, newSize]`.\n  constructor(ranges, inverted = false) {\n    this.ranges = ranges\n    this.inverted = inverted\n  }\n\n  recover(value) {\n    let diff = 0, index = recoverIndex(value)\n    if (!this.inverted) for (let i = 0; i < index; i++)\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]\n    return this.ranges[index * 3] + diff + recoverOffset(value)\n  }\n\n  // : (number, ?number) \u2192 MapResult\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  // : (number, ?number) \u2192 number\n  map(pos, assoc = 1) { return this._map(pos, assoc, true) }\n\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n        let result = start + diff + (side < 0 ? 0 : newSize)\n        if (simple) return result\n        let recover = makeRecover(i / 3, pos - start)\n        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n      }\n      diff += newSize - oldSize\n    }\n    return simple ? pos + diff : new MapResult(pos + diff)\n  }\n\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover)\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize\n      if (pos <= end && i == index * 3) return true\n      diff += this.ranges[i + newIndex] - oldSize\n    }\n    return false\n  }\n\n  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n  // Calls the given function on each of the changed ranges included in\n  // this map.\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff)\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex]\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n      diff += newSize - oldSize\n    }\n  }\n\n  // :: () \u2192 StepMap\n  // Create an inverted version of this map. The result can be used to\n  // map positions in the post-step document to the pre-step document.\n  invert() {\n    return new StepMap(this.ranges, !this.inverted)\n  }\n\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n  }\n\n  // :: (n: number) \u2192 StepMap\n  // Create a map that moves all positions by offset `n` (which may be\n  // negative). This can be useful when applying steps meant for a\n  // sub-document to a larger document, or vice-versa.\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n  }\n}\n\nStepMap.empty = new StepMap([])\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// \u2018[rebasing](/docs/guide/#transform.rebasing)\u2019 steps for\n// collaboration or history management.)\nexport class Mapping {\n  // :: (?[StepMap])\n  // Create a new mapping with the given position maps.\n  constructor(maps, mirror, from, to) {\n    // :: [StepMap]\n    // The step maps in this mapping.\n    this.maps = maps || []\n    // :: number\n    // The starting position in the `maps` array, used when `map` or\n    // `mapResult` is called.\n    this.from = from || 0\n    // :: number\n    // The end position in the `maps` array.\n    this.to = to == null ? this.maps.length : to\n    this.mirror = mirror\n  }\n\n  // :: (?number, ?number) \u2192 Mapping\n  // Create a mapping that maps only through a part of this one.\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to)\n  }\n\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n  }\n\n  // :: (StepMap, ?number)\n  // Add a step map to the end of this mapping. If `mirrors` is\n  // given, it should be the index of the step map that is the mirror\n  // image of this one.\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map)\n    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors)\n  }\n\n  // :: (Mapping)\n  // Add all the step maps in a given mapping to this one (preserving\n  // mirroring information).\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n    }\n  }\n\n  // :: (number) \u2192 ?number\n  // Finds the offset of the step map that mirrors the map at the\n  // given offset, in this mapping (as per the second argument to\n  // `appendMap`).\n  getMirror(n) {\n    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n  }\n\n  setMirror(n, m) {\n    if (!this.mirror) this.mirror = []\n    this.mirror.push(n, m)\n  }\n\n  // :: (Mapping)\n  // Append the inverse of the given mapping to this one.\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null)\n    }\n  }\n\n  // :: () \u2192 Mapping\n  // Create an inverted version of this mapping.\n  invert() {\n    let inverse = new Mapping\n    inverse.appendMappingInverted(this)\n    return inverse\n  }\n\n  // : (number, ?number) \u2192 number\n  // Map a position through this mapping.\n  map(pos, assoc = 1) {\n    if (this.mirror) return this._map(pos, assoc, true)\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc)\n    return pos\n  }\n\n  // : (number, ?number) \u2192 MapResult\n  // Map a position through this mapping, returning a mapping\n  // result.\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  _map(pos, assoc, simple) {\n    let deleted = false, recoverables = null\n\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], rec = recoverables && recoverables[i]\n      if (rec != null && map.touches(pos, rec)) {\n        pos = map.recover(rec)\n        continue\n      }\n\n      let result = map.mapResult(pos, assoc)\n      if (result.recover != null) {\n        let corr = this.getMirror(i)\n        if (corr != null && corr > i && corr < this.to) {\n          if (result.deleted) {\n            i = corr\n            pos = this.maps[corr].recover(result.recover)\n            continue\n          } else {\n            ;(recoverables || (recoverables = Object.create(null)))[corr] = result.recover\n          }\n        }\n      }\n\n      if (result.deleted) deleted = true\n      pos = result.pos\n    }\n\n    return simple ? pos : new MapResult(pos, deleted)\n  }\n}\n", "import {Mapping} from \"./map\"\n\nexport function TransformError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = TransformError.prototype\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype)\nTransformError.prototype.constructor = TransformError\nTransformError.prototype.name = \"TransformError\"\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nexport class Transform {\n  // :: (Node)\n  // Create a transform that starts with the given document.\n  constructor(doc) {\n    // :: Node\n    // The current document (the result of applying the steps in the\n    // transform).\n    this.doc = doc\n    // :: [Step]\n    // The steps in this transform.\n    this.steps = []\n    // :: [Node]\n    // The documents before each of the steps.\n    this.docs = []\n    // :: Mapping\n    // A mapping with the maps for each of the steps in this transform.\n    this.mapping = new Mapping\n  }\n\n  // :: Node The starting document.\n  get before() { return this.docs.length ? this.docs[0] : this.doc }\n\n  // :: (step: Step) \u2192 this\n  // Apply a new step in this transform, saving the result. Throws an\n  // error when the step fails.\n  step(object) {\n    let result = this.maybeStep(object)\n    if (result.failed) throw new TransformError(result.failed)\n    return this\n  }\n\n  // :: (Step) \u2192 StepResult\n  // Try to apply a step in this transformation, ignoring it if it\n  // fails. Returns the step result.\n  maybeStep(step) {\n    let result = step.apply(this.doc)\n    if (!result.failed) this.addStep(step, result.doc)\n    return result\n  }\n\n  // :: bool\n  // True when the document has been changed (when there are any\n  // steps).\n  get docChanged() {\n    return this.steps.length > 0\n  }\n\n  addStep(step, doc) {\n    this.docs.push(this.doc)\n    this.steps.push(step)\n    this.mapping.appendMap(step.getMap())\n    this.doc = doc\n  }\n}\n", "import {ReplaceError} from \"prosemirror-model\"\n\nimport {StepMap} from \"./map\"\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nconst stepsByID = Object.create(null)\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nexport class Step {\n  // :: (doc: Node) \u2192 StepResult\n  // Applies this step to the given document, returning a result\n  // object that either indicates failure, if the step can not be\n  // applied to this document, or indicates success by containing a\n  // transformed document.\n  apply(_doc) { return mustOverride() }\n\n  // :: () \u2192 StepMap\n  // Get the step map that represents the changes made by this step,\n  // and which can be used to transform between positions in the old\n  // and the new document.\n  getMap() { return StepMap.empty }\n\n  // :: (doc: Node) \u2192 Step\n  // Create an inverted version of this step. Needs the document as it\n  // was before the step as argument.\n  invert(_doc) { return mustOverride() }\n\n  // :: (mapping: Mappable) \u2192 ?Step\n  // Map this step through a mappable thing, returning either a\n  // version of that step with its positions adjusted, or `null` if\n  // the step was entirely deleted by the mapping.\n  map(_mapping) { return mustOverride() }\n\n  // :: (other: Step) \u2192 ?Step\n  // Try to merge this step with another one, to be applied directly\n  // after it. Returns the merged step when possible, null if the\n  // steps can't be merged.\n  merge(_other) { return null }\n\n  // :: () \u2192 Object\n  // Create a JSON-serializeable representation of this step. When\n  // defining this for a custom subclass, make sure the result object\n  // includes the step type's [JSON id](#transform.Step^jsonID) under\n  // the `stepType` property.\n  toJSON() { return mustOverride() }\n\n  // :: (Schema, Object) \u2192 Step\n  // Deserialize a step from its JSON representation. Will call\n  // through to the step class' own implementation of this method.\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\")\n    let type = stepsByID[json.stepType]\n    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)\n    return type.fromJSON(schema, json)\n  }\n\n  // :: (string, constructor<Step>)\n  // To be able to serialize steps to JSON, each step needs a string\n  // ID to attach to its JSON representation. Use this method to\n  // register an ID for your step classes. Try to pick something\n  // that's unlikely to clash with steps from other modules.\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id)\n    stepsByID[id] = stepClass\n    stepClass.prototype.jsonID = id\n    return stepClass\n  }\n}\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nexport class StepResult {\n  // : (?Node, ?string)\n  constructor(doc, failed) {\n    // :: ?Node The transformed document.\n    this.doc = doc\n    // :: ?string Text providing information about a failed step.\n    this.failed = failed\n  }\n\n  // :: (Node) \u2192 StepResult\n  // Create a successful step result.\n  static ok(doc) { return new StepResult(doc, null) }\n\n  // :: (string) \u2192 StepResult\n  // Create a failed step result.\n  static fail(message) { return new StepResult(null, message) }\n\n  // :: (Node, number, number, Slice) \u2192 StepResult\n  // Call [`Node.replace`](#model.Node.replace) with the given\n  // arguments. Create a successful result if it succeeds, and a\n  // failed one if it throws a `ReplaceError`.\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice))\n    } catch (e) {\n      if (e instanceof ReplaceError) return StepResult.fail(e.message)\n      throw e\n    }\n  }\n}\n", "import {Slice} from \"prosemirror-model\"\n\nimport {Step, StepResult} from \"./step\"\nimport {StepMap} from \"./map\"\n\n// ::- Replace a part of the document with a slice of new content.\nexport class ReplaceStep extends Step {\n  // :: (number, number, Slice, ?bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`\u2014the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n  constructor(from, to, slice, structure) {\n    super()\n    this.from = from\n    this.to = to\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\")\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  }\n\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) return null\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  }\n\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure != this.structure) return null\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd)\n      return new ReplaceStep(other.from, this.to, slice, this.structure)\n    } else {\n      return null\n    }\n  }\n\n  toJSON() {\n    let json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\")\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  }\n}\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nexport class ReplaceAroundStep extends Step {\n  // :: (number, number, number, number, Slice, number, ?bool)\n  // Create a replace-around step with the given range and gap.\n  // `insert` should be the point in the slice into which the content\n  // of the gap should be moved. `structure` has the same meaning as\n  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {\n    super()\n    this.from = from\n    this.to = to\n    this.gapFrom = gapFrom\n    this.gapTo = gapTo\n    this.slice = slice\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\")\n\n    let gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\")\n    let inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\")\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  }\n\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  }\n\n  toJSON() {\n    let json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\")\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  }\n}\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n", "import {Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) \u2192 ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nexport function liftTarget(range) {\n  let parent = range.parent\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (let depth = range.depth;; --depth) {\n    let node = range.$from.node(depth)\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break\n  }\n}\n\n// :: (NodeRange, number) \u2192 this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  let {$from, $to, depth} = range\n\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  let start = gapStart, end = gapEnd\n\n  let before = Fragment.empty, openStart = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openStart++\n    } else {\n      start--\n    }\n  let after = Fragment.empty, openEnd = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true\n      after = Fragment.from($to.node(d).copy(after))\n      openEnd++\n    } else {\n      end++\n    }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n}\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) \u2192 ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nexport function findWrapping(range, nodeType, attrs, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType)\n  let inner = around && findWrappingInside(innerRange, nodeType)\n  if (!inner) return null\n  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let around = parent.contentMatchAt(startIndex).findWrapping(type)\n  if (!around) return null\n  let outer = around.length ? around[0] : type\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let inner = parent.child(startIndex)\n  let inside = type.contentMatch.findWrapping(inner.type)\n  if (!inside) return null\n  let lastType = inside.length ? inside[inside.length - 1] : type\n  let innerMatch = lastType.contentMatch\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type)\n  if (!innerMatch || !innerMatch.validEnd) return null\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) \u2192 this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--)\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n\n  let start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object) \u2192 this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to = from, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\")\n  let mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type)\n      let mapping = this.mapping.slice(mapFrom)\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) \u2192 this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  let node = this.doc.nodeAt(pos)\n  if (!node) throw new RangeError(\"No node at given position\")\n  if (!type) type = node.type\n  let newNode = type.create(attrs, null, marks || node.marks)\n  if (node.isLeaf)\n    return this.replaceWith(pos, pos + node.nodeSize, newNode)\n\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name)\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n}\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) \u2192 bool\n// Check whether splitting at the given position is allowed.\nexport function canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth\n  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index = $pos.index(d)\n    if (node.type.spec.isolating) return false\n    let rest = node.content.cutByIndex(index, node.childCount)\n    let after = (typesAfter && typesAfter[i]) || node\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs))\n    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n      return false\n  }\n  let index = $pos.indexAfter(base)\n  let baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) \u2192 this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth = 1, typesAfter) {\n  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    let typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n}\n\n// :: (Node, number) \u2192 bool\n// Test whether the blocks before and after a given position can be\n// joined.\nexport function canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) \u2192 ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nexport function joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos)\n  for (let d = $pos.depth;; d--) {\n    let before, after, index = $pos.index(d)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      index++\n      after = $pos.node(d).maybeChild(index)\n    } else {\n      before = $pos.node(d).maybeChild(index - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) return pos\n    if (d == 0) break\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\n\n// :: (number, ?number) \u2192 this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth = 1) {\n  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType) \u2192 ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nexport function insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos\n\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)\n      if (index > 0) return null\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)\n      if (index < $pos.node(d).childCount) return null\n    }\n}\n\n// :: (Node, number, Slice) \u2192 ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nexport function dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos)\n  if (!slice.content.size) return pos\n  let content = slice.content\n  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n      if (pass == 1\n          ? $pos.node(d).canReplace(insertPos, insertPos, content)\n          : $pos.node(d).contentMatchAt(insertPos).findWrapping(content.firstChild.type))\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)\n    }\n  }\n  return null\n}\n", "import {Fragment, Slice} from \"prosemirror-model\"\nimport {Step, StepResult} from \"./step\"\n\nfunction mapFragment(fragment, f, parent) {\n  let mapped = []\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i)\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child))\n    if (child.isInline) child = f(child, parent, i)\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nexport class AddMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    this.from = from\n    this.to = to\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    let parent = $from.node($from.sharedDepth(this.to))\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n      if (!parent.type.allowsMarkType(this.mark.type)) return node\n      return node.mark(this.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\")\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nexport class RemoveMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    this.from = from\n    this.to = to\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to)\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\")\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n", "import {MarkType, Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {AddMarkStep, RemoveMarkStep} from \"./mark_step\"\nimport {ReplaceStep} from \"./replace_step\"\n\n// :: (number, number, Mark) \u2192 this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  let removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline) return\n    let marks = node.marks\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      let newSet = mark.addToSet(marks)\n\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]))\n        }\n      }\n\n      if (adding && adding.to == start)\n        adding.to = end\n      else\n        added.push(adding = new AddMarkStep(start, end, mark))\n    }\n  })\n\n  removed.forEach(s => this.step(s))\n  added.forEach(s => this.step(s))\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>) \u2192 this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark = null) {\n  let matched = [], step = 0\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) return\n    step++\n    let toRemove = null\n    if (mark instanceof MarkType) {\n      let found = mark.isInSet(node.marks)\n      if (found) toRemove = [found]\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark]\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to)\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m\n        }\n        if (found) {\n          found.to = end\n          found.step = step\n        } else {\n          matched.push({style, from: Math.max(pos, from), to: end, step})\n        }\n      }\n    }\n  })\n  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)))\n  return this\n}\n\n// :: (number, NodeType, ?ContentMatch) \u2192 this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {\n  let node = this.doc.nodeAt(pos)\n  let delSteps = [], cur = pos + 1\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize\n    let allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))\n        this.step(new RemoveMarkStep(cur, end, child.marks[j]))\n    }\n    cur = end\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i])\n  return this\n}\n", "import {Fragment, Slice} from \"prosemirror-model\"\n\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\nimport {Transform} from \"./transform\"\nimport {insertPoint} from \"./structure\"\n\n// :: (Node, number, ?number, ?Slice) \u2192 ?Step\n// \u2018Fit\u2019 a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nexport function replaceStep(doc, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size) return null\n\n  let $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) \u2192 this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to = from, slice = Slice.empty) {\n  let step = replaceStep(this.doc, from, to, slice)\n  if (step) this.step(step)\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>) \u2192 this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, number) \u2192 this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (number, union<Fragment, Node, [Node]>) \u2192 this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n  constructor($from, $to, slice) {\n    this.$to = $to\n    this.$from = $from\n    this.unplaced = slice\n\n    this.frontier = []\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i)\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      })\n    }\n\n    this.placed = Fragment.empty\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed))\n  }\n\n  get depth() { return this.frontier.length - 1 }\n\n  fit() {\n    // As long as there's unplaced content, try to place some of it.\n    // If that fails, either increase the open score of the unplaced\n    // slice, or drop nodes from it, and then try again.\n    while (this.unplaced.size) {\n      let fit = this.findFittable()\n      if (fit) this.placeNodes(fit)\n      else this.openMore() || this.dropNode()\n    }\n    // When there's inline content directly after the frontier _and_\n    // directly after `this.$to`, we must generate a `ReplaceAround`\n    // step that pulls that content into the node after the frontier.\n    // That means the fitting must be done to the end of the textblock\n    // node after `this.$to`, not `this.$to` itself.\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth\n    let $from = this.$from, $to = moveInline < 0 ? this.$to : $from.doc.resolve(moveInline)\n    if (this.close($to)) { // If closing to `$to` succeeded, create a step\n      let content = this.placed, openStart = $from.depth, openEnd = $to.depth\n      while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n        content = content.firstChild.content\n        openStart--; openEnd--\n      }\n      let slice = new Slice(content, openStart, openEnd)\n      if (moveInline > -1)\n        return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize)\n      if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n        return new ReplaceStep($from.pos, $to.pos, slice)\n    }\n    return null\n  }\n\n  // Find a position on the start spine of `this.unplaced` that has\n  // content that can be moved somewhere on the frontier. Returns two\n  // depths, one for the slice and one for the frontier.\n  findFittable() {\n    // Only try wrapping nodes (pass 2) after finding a place without\n    // wrapping failed.\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild\n          fragment = parent.content\n        } else {\n          fragment = this.unplaced.content\n        }\n        let first = fragment.firstChild\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let {type, match} = this.frontier[frontierDepth], wrap, inject\n          // In pass 1, if the next node matches, or there is no next\n          // node but the parents look compatible, we've found a\n          // place.\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                            : type.compatibleContent(parent.type)))\n            return {sliceDepth, frontierDepth, parent, inject}\n          // In pass 2, look for a set of wrapping nodes that make\n          // `first` fit here.\n          else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n            return {sliceDepth, frontierDepth, parent, wrap}\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          if (parent && match.matchType(parent.type)) break\n        }\n      }\n    }\n  }\n\n  openMore() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (!inner.childCount || inner.firstChild.isLeaf) return false\n    this.unplaced = new Slice(content, openStart + 1,\n                              Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0))\n    return true\n  }\n\n  dropNode() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                                openAtEnd ? openStart - 1 : openEnd)\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd)\n    }\n  }\n\n  // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n  // Move content from the unplaced slice at `sliceDepth` to the\n  // frontier node at `frontierDepth`. Close that frontier node when\n  // applicable.\n  placeNodes({sliceDepth, frontierDepth, parent, inject, wrap}) {\n    while (this.depth > frontierDepth) this.closeFrontierNode()\n    if (wrap) for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i])\n\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content\n    let openStart = slice.openStart - sliceDepth\n    let taken = 0, add = []\n    let {match, type} = this.frontier[frontierDepth]\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i))\n      match = match.matchFragment(inject)\n    }\n    // Computes the amount of (end) open nodes at the end of the\n    // fragment. When 0, the parent is open, but no more. When\n    // negative, nothing is open.\n    let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd)\n    // Scan over the fragment, fitting as many child nodes as\n    // possible.\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type)\n      if (!matches) break\n      taken++\n      if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n        match = matches\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                                taken == fragment.childCount ? openEndCount : -1))\n      }\n    }\n    let toEnd = taken == fragment.childCount\n    if (!toEnd) openEndCount = -1\n\n    // If the parent types match, and the entire node was moved, and\n    // it's not open, close this frontier node right away.\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type) this.closeFrontierNode()\n    else this.frontier[frontierDepth].match = match\n\n    // Add new frontier nodes for any open nodes at the end.\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild\n      this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)})\n      cur = node.content\n    }\n\n    // Update `this.unplaced`. Drop the entire node from which we\n    // placed it we got to its end, otherwise just drop the placed\n    // nodes.\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n      : sliceDepth == 0 ? Slice.empty\n      : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                  sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1)\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add))\n  }\n\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock) return -1\n    let top = this.frontier[this.depth], level\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n        (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) return -1\n\n    let {depth} = this.$to, after = this.$to.after(depth)\n    while (depth > 1 && after == this.$to.end(--depth)) ++after\n    return after\n  }\n\n  findCloseLevel($to) {\n    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n      let {match, type} = this.frontier[i]\n      let fit = contentAfterFits($to, i, type, match, false)\n      if (!fit) continue\n      for (let d = i - 1; d >= 0; d--) {\n        let {match, type} = this.frontier[d]\n        let matches = contentAfterFits($to, d, type, match, true)\n        if (!matches || matches.childCount) continue scan\n      }\n      return {depth: i, fit}\n    }\n  }\n\n  close($to) {\n    let close = this.findCloseLevel($to)\n    if (!close) return false\n\n    while (this.depth > close.depth) this.closeFrontierNode()\n    if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit)\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d))\n      this.openFrontierNode(node.type, node.attrs, add)\n    }\n    return true\n  }\n\n  openFrontierNode(type, attrs, content) {\n    let top = this.frontier[this.depth]\n    top.match = top.match.matchType(type)\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)))\n    this.frontier.push({type, match: type.contentMatch})\n  }\n\n  closeFrontierNode() {\n    let open = this.frontier.pop()\n    let add = open.match.fillBefore(Fragment.empty, true)\n    if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add)\n  }\n}\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count)\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content)\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node\n  let frag = node.content\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0))\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag)\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true))\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth)\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null\n  let fit = match.fillBefore(node.content, true, index)\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks)) return true\n  return false\n}\n\n// :: (number, number, Slice) \u2192 this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) return this.deleteRange(from, to)\n\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  if (fitsTrivially($from, $to, slice))\n    return this.step(new ReplaceStep(from, to, slice))\n\n  let targetDepths = coveredDepths($from, this.doc.resolve(to))\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop()\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  let preferredTarget = -($from.depth + 1)\n  targetDepths.unshift(preferredTarget)\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec\n    if (spec.defining || spec.isolating) break\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d\n    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d)\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget)\n\n  let leftNodes = [], preferredDepth = slice.openStart\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openStart) break\n    content = node.content\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    preferredDepth -= 1\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    preferredDepth -= 2\n\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1)\n    let insert = leftNodes[openDepth]\n    if (!insert) continue\n    for (let i = 0; i < targetDepths.length; i++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd))\n    }\n  }\n\n  let startSteps = this.steps.length\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    this.replace(from, to, slice)\n    if (this.steps.length > startSteps) break\n    let depth = targetDepths[i]\n    if (i < 0) continue\n    from = $from.before(depth); to = $to.after(depth)\n  }\n  return this\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0)\n    let start = match.fillBefore(fragment).append(fragment)\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true))\n  }\n  return fragment\n}\n\n// :: (number, number, Node) \u2192 this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(this.doc, from, node.type)\n    if (point != null) from = to = point\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number) \u2192 this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  let covered = coveredDepths($from, $to)\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      return this.delete($from.start(depth), $to.end(depth))\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return this.delete($from.before(depth), $to.after(depth))\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return this.delete($from.before(d), to)\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos) \u2192 [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth)\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d)\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) break\n    if (start == $to.start(d)) result.push(d)\n  }\n  return result\n}\n\n"],
  "mappings": "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",
  "names": []
}
