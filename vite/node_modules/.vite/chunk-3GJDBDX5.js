import {
  init_index_es as init_index_es4,
  keydownHandler
} from "./chunk-GSCWWJLB.js";
import {
  AllSelection,
  NodeSelection,
  Plugin,
  PluginKey,
  Selection,
  SelectionRange,
  TextSelection,
  init_index_es as init_index_es3
} from "./chunk-37MHF4IQ.js";
import {
  Transform,
  dropPoint,
  init_index_es as init_index_es2
} from "./chunk-YWSQD36O.js";
import {
  DOMParser,
  DOMSerializer,
  Fragment,
  Mark,
  Slice,
  init_index_es
} from "./chunk-R7NIYD52.js";
import {
  __esm,
  __export
} from "./chunk-A5ICIBVI.js";

// ../node_modules/prosemirror-tables/node_modules/prosemirror-view/dist/index.es.js
function scanFor(node2, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node2 == targetNode && off == targetOff) {
      return true;
    }
    if (off == (dir < 0 ? 0 : nodeSize(node2))) {
      var parent = node2.parentNode;
      if (parent.nodeType != 1 || hasBlockDesc(node2) || atomElements.test(node2.nodeName) || node2.contentEditable == "false") {
        return false;
      }
      off = domIndex(node2) + (dir < 0 ? 0 : 1);
      node2 = parent;
    } else if (node2.nodeType == 1) {
      node2 = node2.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node2.contentEditable == "false") {
        return false;
      }
      off = dir < 0 ? nodeSize(node2) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node2) {
  return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
}
function isOnEdge(node2, offset, parent) {
  for (var atStart = offset == 0, atEnd = offset == nodeSize(node2); atStart || atEnd; ) {
    if (node2 == parent) {
      return true;
    }
    var index = domIndex(node2);
    node2 = node2.parentNode;
    if (!node2) {
      return false;
    }
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node2);
  }
}
function hasBlockDesc(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode) {
    if (desc = cur.pmViewDesc) {
      break;
    }
  }
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
function keyEvent(keyCode, key2) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key2;
  return event;
}
function windowRect(doc) {
  return {
    left: 0,
    right: doc.documentElement.clientWidth,
    top: 0,
    bottom: doc.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node2) {
  var rect = node2.getBoundingClientRect();
  var scaleX = rect.width / node2.offsetWidth || 1;
  var scaleY = rect.height / node2.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node2.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node2.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  var doc = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent) {
      break;
    }
    if (parent.nodeType != 1) {
      continue;
    }
    var atTop = parent == doc.body || parent.nodeType != 1;
    var bounding = atTop ? windowRect(doc) : clientRect(parent);
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top")) {
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    } else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) {
      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    }
    if (rect.left < bounding.left + getSide(scrollThreshold, "left")) {
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    } else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) {
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    }
    if (moveX || moveY) {
      if (atTop) {
        doc.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = parent.scrollLeft, startY = parent.scrollTop;
        if (moveY) {
          parent.scrollTop += moveY;
        }
        if (moveX) {
          parent.scrollLeft += moveX;
        }
        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop) {
      break;
    }
  }
}
function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var refDOM, refTop;
  for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (dom == view.dom || !view.dom.contains(dom)) {
      continue;
    }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  var stack = [], doc = dom.ownerDocument;
  for (; dom; dom = parentNode(dom)) {
    stack.push({ dom, top: dom.scrollTop, left: dom.scrollLeft });
    if (dom == doc) {
      break;
    }
  }
  return stack;
}
function resetScrollPos(ref) {
  var refDOM = ref.refDOM;
  var refTop = ref.refTop;
  var stack = ref.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (var i = 0; i < stack.length; i++) {
    var ref = stack[i];
    var dom = ref.dom;
    var top = ref.top;
    var left = ref.left;
    if (dom.scrollTop != top + dTop) {
      dom.scrollTop = top + dTop;
    }
    if (dom.scrollLeft != left) {
      dom.scrollLeft = left;
    }
  }
}
function focusPreventScroll(dom) {
  if (dom.setActive) {
    return dom.setActive();
  }
  if (preventScrollSupported) {
    return dom.focus(preventScrollSupported);
  }
  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node2, coords) {
  var closest, dxClosest = 2e8, coordsClosest, offset = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child = node2.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    var rects = void 0;
    if (child.nodeType == 1) {
      rects = child.getClientRects();
    } else if (child.nodeType == 3) {
      rects = textRange(child).getClientRects();
    } else {
      continue;
    }
    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
          if (child.nodeType == 1 && dx) {
            offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          }
          continue;
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) {
        offset = childIndex + 1;
      }
    }
  }
  if (closest && closest.nodeType == 3) {
    return findOffsetInText(closest, coordsClosest);
  }
  if (!closest || dxClosest && closest.nodeType == 1) {
    return { node: node2, offset };
  }
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node2, coords) {
  var len = node2.nodeValue.length;
  var range = document.createRange();
  for (var i = 0; i < len; i++) {
    range.setEnd(node2, i + 1);
    range.setStart(node2, i);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom) {
      continue;
    }
    if (inRect(coords, rect)) {
      return { node: node2, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
  }
  return { node: node2, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
    return parent;
  }
  return dom;
}
function posFromElement(view, elt, coords) {
  var ref = findOffsetInNode(elt, coords);
  var node2 = ref.node;
  var offset = ref.offset;
  var bias = -1;
  if (node2.nodeType == 1 && !node2.firstChild) {
    var rect = node2.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node2, offset, bias);
}
function posFromCaret(view, node2, offset, coords) {
  var outside = -1;
  for (var cur = node2; ; ) {
    if (cur == view.dom) {
      break;
    }
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) {
      return null;
    }
    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) {
        outside = desc.posBefore;
      } else if (rect.right < coords.left || rect.bottom < coords.top) {
        outside = desc.posAfter;
      } else {
        break;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node2, offset);
}
function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      var child = element.childNodes[i];
      if (child.nodeType == 1) {
        var rects = child.getClientRects();
        for (var j = 0; j < rects.length; j++) {
          var rect = rects[j];
          if (inRect(coords, rect)) {
            return elementFromPoint(child, coords, rect);
          }
        }
      }
      if ((i = (i + 1) % len) == startI) {
        break;
      }
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  var assign, assign$1;
  var root = view.root, node2, offset;
  if (root.caretPositionFromPoint) {
    try {
      var pos$1 = root.caretPositionFromPoint(coords.left, coords.top);
      if (pos$1) {
        assign = pos$1, node2 = assign.offsetNode, offset = assign.offset;
      }
    } catch (_) {
    }
  }
  if (!node2 && root.caretRangeFromPoint) {
    var range = root.caretRangeFromPoint(coords.left, coords.top);
    if (range) {
      assign$1 = range, node2 = assign$1.startContainer, offset = assign$1.startOffset;
    }
  }
  var elt = root.elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) {
      return null;
    }
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) {
      return null;
    }
  }
  if (result.safari && elt.draggable) {
    node2 = offset = null;
  }
  elt = targetKludge(elt, coords);
  if (node2) {
    if (result.gecko && node2.nodeType == 1) {
      offset = Math.min(offset, node2.childNodes.length);
      if (offset < node2.childNodes.length) {
        var next = node2.childNodes[offset], box$1;
        if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left && box$1.bottom > coords.top) {
          offset++;
        }
      }
    }
    if (node2 == view.dom && offset == node2.childNodes.length - 1 && node2.lastChild.nodeType == 1 && coords.top > node2.lastChild.getBoundingClientRect().bottom) {
      pos = view.state.doc.content.size;
    } else if (offset == 0 || node2.nodeType != 1 || node2.childNodes[offset - 1].nodeName != "BR") {
      pos = posFromCaret(view, node2, offset, coords);
    }
  }
  if (pos == null) {
    pos = posFromElement(view, elt, coords);
  }
  var desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect(object, bias) {
  var rects = object.getClientRects();
  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
function coordsAtPos(view, pos, side) {
  var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  var node2 = ref.node;
  var offset = ref.offset;
  var supportEmptyRange = result.webkit || result.gecko;
  if (node2.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node2.nodeValue) || (side < 0 ? !offset : offset == node2.nodeValue.length))) {
      var rect = singleRect(textRange(node2, offset, offset), side);
      if (result.gecko && offset && /\s/.test(node2.nodeValue[offset - 1]) && offset < node2.nodeValue.length) {
        var rectBefore = singleRect(textRange(node2, offset - 1, offset - 1), -1);
        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node2, offset, offset + 1), -1);
          if (rectAfter.top != rect.top) {
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
      }
      return rect;
    } else {
      var from2 = offset, to = offset, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset == node2.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node2, from2, to), takeSide), takeSide < 0);
    }
  }
  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset && (side < 0 || offset == nodeSize(node2))) {
      var before = node2.childNodes[offset - 1];
      if (before.nodeType == 1) {
        return flattenH(before.getBoundingClientRect(), false);
      }
    }
    if (offset < nodeSize(node2)) {
      var after = node2.childNodes[offset];
      if (after.nodeType == 1) {
        return flattenH(after.getBoundingClientRect(), true);
      }
    }
    return flattenH(node2.getBoundingClientRect(), side >= 0);
  }
  if (offset && (side < 0 || offset == nodeSize(node2))) {
    var before$1 = node2.childNodes[offset - 1];
    var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1)) : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
    if (target) {
      return flattenV(singleRect(target, 1), false);
    }
  }
  if (offset < nodeSize(node2)) {
    var after$1 = node2.childNodes[offset];
    var target$1 = after$1.nodeType == 3 ? textRange(after$1, 0, supportEmptyRange ? 0 : 1) : after$1.nodeType == 1 ? after$1 : null;
    if (target$1) {
      return flattenV(singleRect(target$1, -1), true);
    }
  }
  return flattenV(singleRect(node2.nodeType == 3 ? textRange(node2) : node2, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0) {
    return rect;
  }
  var x = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top) {
  if (rect.height == 0) {
    return rect;
  }
  var y = top ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  var viewState = view.state, active = view.root.activeElement;
  if (viewState != state) {
    view.updateState(state);
  }
  if (active != view.dom) {
    view.focus();
  }
  try {
    return f();
  } finally {
    if (viewState != state) {
      view.updateState(viewState);
    }
    if (active != view.dom && active) {
      active.focus();
    }
  }
}
function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function() {
    var ref = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    var dom = ref.node;
    for (; ; ) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) {
        break;
      }
      if (nearest.node.isBlock) {
        dom = nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    var coords = coordsAtPos(view, $pos.pos, 1);
    for (var child = dom.firstChild; child; child = child.nextSibling) {
      var boxes = void 0;
      if (child.nodeType == 1) {
        boxes = child.getClientRects();
      } else if (child.nodeType == 3) {
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      } else {
        continue;
      }
      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top && (dir == "up" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1)) {
          return false;
        }
      }
    }
    return true;
  });
}
function endOfTextblockHorizontal(view, state, dir) {
  var ref = state.selection;
  var $head = ref.$head;
  if (!$head.parent.isTextblock) {
    return false;
  }
  var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
  var sel = getSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) {
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  }
  return withFlushedState(view, state, function() {
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) {
      sel.caretBidiLevel = oldBidiLevel;
    }
    return result2;
  });
}
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) {
    return cachedResult;
  }
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc);
  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);
}
function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild, written = false;
  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM) {
    view.trackWrites = null;
  }
}
function OuterDecoLevel(nodeName) {
  if (nodeName) {
    this.nodeName = nodeName;
  }
}
function computeOuterDeco(outerDeco, node2, needsWrap) {
  if (outerDeco.length == 0) {
    return noDeco;
  }
  var top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result2 = [top];
  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs;
    if (!attrs) {
      continue;
    }
    if (attrs.nodeName) {
      result2.push(top = new OuterDecoLevel(attrs.nodeName));
    }
    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) {
        continue;
      }
      if (needsWrap && result2.length == 1) {
        result2.push(top = new OuterDecoLevel(node2.isInline ? "span" : "div"));
      }
      if (name == "class") {
        top.class = (top.class ? top.class + " " : "") + val;
      } else if (name == "style") {
        top.style = (top.style ? top.style + ";" : "") + val;
      } else if (name != "nodeName") {
        top[name] = val;
      }
    }
  }
  return result2;
}
function patchOuterDeco(outerDOM, nodeDOM2, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco) {
    return nodeDOM2;
  }
  var curDOM = nodeDOM2;
  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      var parent = void 0;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (var name in prev) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
      dom.removeAttribute(name);
    }
  }
  for (var name$1 in cur) {
    if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1]) {
      dom.setAttribute(name$1, cur[name$1]);
    }
  }
  if (prev.class != cur.class) {
    var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : nothing;
    var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing;
    for (var i = 0; i < prevList.length; i++) {
      if (curList.indexOf(prevList[i]) == -1) {
        dom.classList.remove(prevList[i]);
      }
    }
    for (var i$1 = 0; i$1 < curList.length; i$1++) {
      if (prevList.indexOf(curList[i$1]) == -1) {
        dom.classList.add(curList[i$1]);
      }
    }
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style)) {
        dom.style.removeProperty(m[1]);
      }
    }
    if (cur.style) {
      dom.style.cssText += cur.style;
    }
  }
}
function applyOuterDeco(dom, deco, node2) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node2, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].type.eq(b[i].type)) {
      return false;
    }
  }
  return true;
}
function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
function preMatch(frag, descs) {
  var fI = frag.childCount, dI = descs.length, matched = new Map();
  for (; fI > 0 && dI > 0; dI--) {
    var desc = descs[dI - 1], node2 = desc.node;
    if (!node2) {
      continue;
    }
    if (node2 != frag.child(fI - 1)) {
      break;
    }
    --fI;
    matched.set(desc, fI);
  }
  return { index: fI, matched };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  var locals3 = deco.locals(parent), offset = 0;
  if (locals3.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child = parent.child(i);
      onNode(child, locals3, deco.forChild(offset, child), i);
      offset += child.nodeSize;
    }
    return;
  }
  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0; ; ) {
    if (decoIndex < locals3.length && locals3[decoIndex].to == offset) {
      var widget2 = locals3[decoIndex++], widgets = void 0;
      while (decoIndex < locals3.length && locals3[decoIndex].to == offset) {
        (widgets || (widgets = [widget2])).push(locals3[decoIndex++]);
      }
      if (widgets) {
        widgets.sort(compareSide);
        for (var i$1 = 0; i$1 < widgets.length; i$1++) {
          onWidget(widgets[i$1], parentIndex, !!restNode);
        }
      } else {
        onWidget(widget2, parentIndex, !!restNode);
      }
    }
    var child$1 = void 0, index = void 0;
    if (restNode) {
      index = -1;
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child$1 = parent.child(parentIndex++);
    } else {
      break;
    }
    for (var i$2 = 0; i$2 < active.length; i$2++) {
      if (active[i$2].to <= offset) {
        active.splice(i$2--, 1);
      }
    }
    while (decoIndex < locals3.length && locals3[decoIndex].from <= offset && locals3[decoIndex].to > offset) {
      active.push(locals3[decoIndex++]);
    }
    var end = offset + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end;
      if (decoIndex < locals3.length && locals3[decoIndex].from < cutAt) {
        cutAt = locals3[decoIndex].from;
      }
      for (var i$3 = 0; i$3 < active.length; i$3++) {
        if (active[i$3].to < cutAt) {
          cutAt = active[i$3].to;
        }
      }
      if (cutAt < end) {
        restNode = child$1.cut(cutAt - offset);
        child$1 = child$1.cut(0, cutAt - offset);
        end = cutAt;
        index = -1;
      }
    }
    var outerDeco = !active.length ? nothing : child$1.isInline && !child$1.isLeaf ? active.filter(function(d) {
      return !d.inline;
    }) : active.slice();
    onNode(child$1, outerDeco, deco.forChild(offset, child$1), index);
    offset = end;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node2, offset) {
  for (; ; ) {
    if (node2.nodeType == 3) {
      return node2;
    }
    if (node2.nodeType == 1 && offset > 0) {
      if (node2.childNodes.length > offset && node2.childNodes[offset].nodeType == 3) {
        return node2.childNodes[offset];
      }
      node2 = node2.childNodes[offset - 1];
      offset = nodeSize(node2);
    } else if (node2.nodeType == 1 && offset < node2.childNodes.length) {
      node2 = node2.childNodes[offset];
      offset = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (var i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    var child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText) {
      continue;
    }
    var str = child.text;
    while (i < frag.childCount) {
      var next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText) {
        break;
      }
      str += next.text;
    }
    if (pos >= from2) {
      var found = str.lastIndexOf(text, to - childStart);
      if (found >= 0 && found + text.length + childStart >= from2) {
        return childStart + found;
      }
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  var result2 = [];
  for (var i = 0, off = 0; i < nodes.length; i++) {
    var child = nodes[i], start2 = off, end = off += child.size;
    if (start2 >= to || end <= from2) {
      result2.push(child);
    } else {
      if (start2 < from2) {
        result2.push(child.slice(0, from2 - start2, view));
      }
      if (replacement) {
        result2.push(replacement);
        replacement = null;
      }
      if (end > to) {
        result2.push(child.slice(to - start2, child.size, view));
      }
    }
  }
  return result2;
}
function selectionFromDOM(view, origin) {
  var domSel = view.root.getSelection(), doc = view.state.doc;
  if (!domSel.focusNode) {
    return null;
  }
  var nearestDesc2 = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc2 && nearestDesc2.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  if (head < 0) {
    return null;
  }
  var $head = doc.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc2 && !nearestDesc2.node) {
      nearestDesc2 = nearestDesc2.parent;
    }
    if (nearestDesc2 && nearestDesc2.node.isAtom && NodeSelection.isSelectable(nearestDesc2.node) && nearestDesc2.parent && !(nearestDesc2.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc2.dom))) {
      var pos = nearestDesc2.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (anchor < 0) {
      return null;
    }
    $anchor = doc.resolve(anchor);
  }
  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force) {
  var sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view)) {
    return;
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent) {
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      }
      if (!sel.empty && !sel.$from.parent.inlineContent) {
        resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) {
        resetEditable(resetEditableFrom);
      }
      if (resetEditableTo) {
        resetEditable(resetEditableTo);
      }
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) {
        removeClassOnSelectionChange(view);
      }
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
function temporarilyEditableNear(view, pos) {
  var ref = view.docView.domFromPos(pos, 0);
  var node2 = ref.node;
  var offset = ref.offset;
  var after = offset < node2.childNodes.length ? node2.childNodes[offset] : null;
  var before = offset ? node2.childNodes[offset - 1] : null;
  if (result.safari && after && after.contentEditable == "false") {
    return setEditable(after);
  }
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after) {
      return setEditable(after);
    } else if (before) {
      return setEditable(before);
    }
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (result.safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  var doc = view.dom.ownerDocument;
  doc.removeEventListener("selectionchange", view.hideSelectionGuard);
  var domSel = view.root.getSelection();
  var node2 = domSel.anchorNode, offset = domSel.anchorOffset;
  doc.addEventListener("selectionchange", view.hideSelectionGuard = function() {
    if (domSel.anchorNode != node2 || domSel.anchorOffset != offset) {
      doc.removeEventListener("selectionchange", view.hideSelectionGuard);
      setTimeout(function() {
        if (!editorOwnsSelection(view) || view.state.selection.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        }
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  var domSel = view.root.getSelection(), range = document.createRange();
  var node2 = view.cursorWrapper.dom, img = node2.nodeName == "IMG";
  if (img) {
    range.setEnd(node2.parentNode, domIndex(node2) + 1);
  } else {
    range.setEnd(node2, 0);
  }
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
    node2.disabled = true;
    node2.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) {
        desc.selectNode();
      }
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent) {
      view.lastSelectedViewDesc.deselectNode();
    }
    view.lastSelectedViewDesc = null;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function(f) {
    return f(view, $anchor, $head);
  }) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) {
    return false;
  }
  return hasSelection(view);
}
function hasSelection(view) {
  var sel = view.root.getSelection();
  if (!sel.anchorNode) {
    return false;
  }
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.root.getSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  var ref = state.selection;
  var $anchor = ref.$anchor;
  var $head = ref.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection) {
        return apply(view, next);
      }
      return false;
    } else if (!(result.mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head, node2 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node2 || node2.isText) {
        return false;
      }
      var nodePos = dir < 0 ? $head.pos - node2.nodeSize : $head.pos;
      if (!(node2.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) {
        return false;
      }
      if (NodeSelection.isSelectable(node2)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node2.nodeSize) : $head));
      } else if (result.webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node2.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var next$1 = moveSelectionBlock(view.state, dir);
    if (next$1) {
      return apply(view, next$1);
    }
    return false;
  }
}
function nodeLen(node2) {
  return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
}
function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft(view) {
  var sel = view.root.getSelection();
  var node2 = sel.focusNode, offset = sel.focusOffset;
  if (!node2) {
    return;
  }
  var moveNode, moveOffset, force = false;
  if (result.gecko && node2.nodeType == 1 && offset < nodeLen(node2) && isIgnorable(node2.childNodes[offset])) {
    force = true;
  }
  for (; ; ) {
    if (offset > 0) {
      if (node2.nodeType != 1) {
        break;
      } else {
        var before = node2.childNodes[offset - 1];
        if (isIgnorable(before)) {
          moveNode = node2;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node2 = before;
          offset = node2.nodeValue.length;
        } else {
          break;
        }
      }
    } else if (isBlockNode(node2)) {
      break;
    } else {
      var prev = node2.previousSibling;
      while (prev && isIgnorable(prev)) {
        moveNode = node2.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node2 = node2.parentNode;
        if (node2 == view.dom) {
          break;
        }
        offset = 0;
      } else {
        node2 = prev;
        offset = nodeLen(node2);
      }
    }
  }
  if (force) {
    setSelFocus(view, sel, node2, offset);
  } else if (moveNode) {
    setSelFocus(view, sel, moveNode, moveOffset);
  }
}
function skipIgnoredNodesRight(view) {
  var sel = view.root.getSelection();
  var node2 = sel.focusNode, offset = sel.focusOffset;
  if (!node2) {
    return;
  }
  var len = nodeLen(node2);
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset < len) {
      if (node2.nodeType != 1) {
        break;
      }
      var after = node2.childNodes[offset];
      if (isIgnorable(after)) {
        moveNode = node2;
        moveOffset = ++offset;
      } else {
        break;
      }
    } else if (isBlockNode(node2)) {
      break;
    } else {
      var next = node2.nextSibling;
      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node2 = node2.parentNode;
        if (node2 == view.dom) {
          break;
        }
        offset = len = 0;
      } else {
        node2 = next;
        offset = 0;
        len = nodeLen(node2);
      }
    }
  }
  if (moveNode) {
    setSelFocus(view, sel, moveNode, moveOffset);
  }
}
function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSelFocus(view, sel, node2, offset) {
  if (selectionCollapsed(sel)) {
    var range = document.createRange();
    range.setEnd(node2, offset);
    range.setStart(node2, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node2, offset);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  setTimeout(function() {
    if (view.state == state) {
      selectionToDOM(view);
    }
  }, 50);
}
function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1) {
    return false;
  }
  if (result.mac && mods.indexOf("m") > -1) {
    return false;
  }
  var $from = sel.$from;
  var $to = sel.$to;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection) {
      return apply(view, next);
    }
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection)) {
    return true;
  }
  var ref = view.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var empty2 = ref.empty;
  if (!$head.sameParent($anchor)) {
    return true;
  }
  if (!empty2) {
    return false;
  }
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
    return true;
  }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) {
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    } else {
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    }
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node2, state) {
  view.domObserver.stop();
  node2.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!result.safari || view.state.selection.$head.parentOffset > 0) {
    return;
  }
  var ref = view.root.getSelection();
  var focusNode = ref.focusNode;
  var focusOffset = ref.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child = focusNode.firstChild;
    switchEditable(view, child, true);
    setTimeout(function() {
      return switchEditable(view, child, false);
    }, 20);
  }
}
function getMods(event) {
  var result2 = "";
  if (event.ctrlKey) {
    result2 += "c";
  }
  if (event.metaKey) {
    result2 += "m";
  }
  if (event.altKey) {
    result2 += "a";
  }
  if (event.shiftKey) {
    result2 += "s";
  }
  return result2;
}
function captureKeyDown(view, event) {
  var code = event.keyCode, mods = getMods(event);
  if (code == 8 || result.mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
  } else if (code == 46 || result.mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37) {
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 39) {
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (code == 38) {
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 40) {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (mods == (result.mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function parseBetween(view, from_, to_) {
  var ref = view.docView.parseRange(from_, to_);
  var parent = ref.node;
  var fromOffset = ref.fromOffset;
  var toOffset = ref.toOffset;
  var from2 = ref.from;
  var to = ref.to;
  var domSel = view.root.getSelection(), find2 = null, anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel)) {
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
  }
  if (result.chrome && view.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node2 = parent.childNodes[off - 1], desc = node2.pmViewDesc;
      if (node2.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size) {
        break;
      }
    }
  }
  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from2);
  var sel = null, doc = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
    editableContent: true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    var anchor$1 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null) {
      head = anchor$1;
    }
    sel = { anchor: anchor$1 + from2, head: head + from2 };
  }
  return { doc, sel, from: from2, to };
}
function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
}
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  if (from2 < 0) {
    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      var tr$1 = view.state.tr.setSelection(newSel);
      if (origin == "pointer") {
        tr$1.setMeta("pointer", true);
      } else if (origin == "key") {
        tr$1.scrollIntoView();
      }
      view.dispatch(tr$1);
    }
    return;
  }
  var $before = view.state.doc.resolve(from2);
  var shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  var sel = view.state.selection;
  var parse = parseBetween(view, from2, to);
  if (result.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {
    var text = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size = text && text.nodeValue ? text.nodeValue.length : 1;
    parse.sel = { anchor: parse.sel.anchor + size, head: parse.sel.anchor + size };
  }
  var doc = view.state.doc, compare = doc.slice(parse.from, parse.to);
  var preferredPos, preferredSide;
  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.lastKeyCode = null;
  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) && addedNodes.some(function(n) {
      return n.nodeName == "DIV" || n.nodeName == "P";
    }) && view.someProp("handleKeyDown", function(f) {
      return f(view, keyEvent(13, "Enter"));
    })) {
      view.lastIOSEnter = 0;
      return;
    } else {
      if (parse.sel) {
        var sel$1 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel$1 && !sel$1.eq(view.state.selection)) {
          view.dispatch(view.state.tr.setSelection(sel$1));
        }
      }
      return;
    }
  }
  view.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  var $from = parse.doc.resolveNoCache(change.start - parse.from);
  var $to = parse.doc.resolveNoCache(change.endB - parse.from);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
  var nextSel;
  if ((result.ios && view.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n) {
    return n.nodeName == "DIV" || n.nodeName == "P";
  })) || !inlineChange && $from.pos < parse.doc.content.size && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function(f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f) {
    return f(view, keyEvent(8, "Backspace"));
  })) {
    if (result.android && result.chrome) {
      view.domObserver.suppressSelectionUpdates();
    }
    return;
  }
  if (result.chrome && result.android && change.toB == change.from) {
    view.lastAndroidDelete = Date.now();
  }
  if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(function() {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  var chFrom = change.start, chTo = change.endA;
  var tr, storedMarks, markChange, $from1;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function() {
          return selectionToDOM(view);
        }, 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
    } else if (change.endA == change.endB && ($from1 = doc.resolve(change.start)) && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add") {
        tr.addMark(chFrom, chTo, markChange.mark);
      } else {
        tr.removeMark(chFrom, chTo, markChange.mark);
      }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var text$1 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function(f) {
        return f(view, chFrom, chTo, text$1);
      })) {
        return;
      }
      tr = view.state.tr.insertText(text$1, chFrom, chTo);
    }
  }
  if (!tr) {
    tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
  }
  if (parse.sel) {
    var sel$2 = resolveSelection(view, tr.doc, parse.sel);
    if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty && (change.from != change.toB || view.lastAndroidDelete < Date.now() - 100) && (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) || result.ie && sel$2.empty && sel$2.head == chFrom)) {
      tr.setSelection(sel$2);
    }
  }
  if (storedMarks) {
    tr.ensureMarks(storedMarks);
  }
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) {
    return null;
  }
  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  var added = curMarks, removed = prevMarks, type, mark, update3;
  for (var i = 0; i < prevMarks.length; i++) {
    added = prevMarks[i].removeFromSet(added);
  }
  for (var i$1 = 0; i$1 < curMarks.length; i$1++) {
    removed = curMarks[i$1].removeFromSet(removed);
  }
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update3 = function(node2) {
      return node2.mark(mark.addToSet(node2.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update3 = function(node2) {
      return node2.mark(mark.removeFromSet(node2.marks));
    };
  } else {
    return null;
  }
  var updated = [];
  for (var i$2 = 0; i$2 < prev.childCount; i$2++) {
    updated.push(update3(prev.child(i$2)));
  }
  if (Fragment.from(updated).eq(cur)) {
    return { mark, type };
  }
}
function looksLikeJoin(old, start2, end, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end - start2 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) {
    return false;
  }
  var $start = old.resolve(start2);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
    return false;
  }
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) {
    return false;
  }
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start2 = a.findDiffStart(b, pos);
  if (start2 == null) {
    return null;
  }
  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);
  var endA = ref.a;
  var endB = ref.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a.size < b.size) {
    var move2 = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move2;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    var move$1 = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move$1;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
function serializeForClipboard(view, slice) {
  var context = [];
  var content = slice.content;
  var openStart = slice.openStart;
  var openEnd = slice.openEnd;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node2 = content.firstChild;
    context.push(node2.type.name, node2.attrs != node2.type.defaultAttrs ? node2.attrs : null);
    content = node2.content;
  }
  var serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  var doc = detachedDoc(), wrap = doc.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, { document: doc }));
  var firstChild = wrap.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = doc.createElement(needsWrap[i]);
      while (wrap.firstChild) {
        wrapper.appendChild(wrap.firstChild);
      }
      wrap.appendChild(wrapper);
    }
    firstChild = wrap.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1) {
    firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context));
  }
  var text = view.someProp("clipboardTextSerializer", function(f) {
    return f(slice);
  }) || slice.content.textBetween(0, slice.content.size, "\n\n");
  return { dom: wrap, text };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice;
  if (!html && !text) {
    return null;
  }
  var asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", function(f) {
      text = f(text, inCode || plainText);
    });
    if (inCode) {
      return new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0);
    }
    var parsed = view.someProp("clipboardTextParser", function(f) {
      return f(text, $context, plainText);
    });
    if (parsed) {
      slice = parsed;
    } else {
      dom = document.createElement("div");
      text.trim().split(/(?:\r\n?|\n)+/).forEach(function(block) {
        dom.appendChild(document.createElement("p")).textContent = block;
      });
    }
  } else {
    view.someProp("transformPastedHTML", function(f) {
      html = f(html);
    });
    dom = readHTML(html);
  }
  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (!slice) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice = parser.parseSlice(dom, { preserveWhitespace: !!(asText || sliceData), context: $context });
  }
  if (sliceData) {
    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3]);
  } else {
    slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), false);
  }
  view.someProp("transformPasted", function(f) {
    slice = f(slice);
  });
  return slice;
}
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) {
    return fragment;
  }
  var loop = function(d2) {
    var parent = $context.node(d2);
    var match = parent.contentMatchAt($context.index(d2));
    var lastWrap = void 0, result2 = [];
    fragment.forEach(function(node2) {
      if (!result2) {
        return;
      }
      var wrap = match.findWrapping(node2.type), inLast;
      if (!wrap) {
        return result2 = null;
      }
      if (inLast = result2.length && lastWrap.length && addToSibling(wrap, lastWrap, node2, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length) {
          result2[result2.length - 1] = closeRight(result2[result2.length - 1], lastWrap.length);
        }
        var wrapped = withWrappers(node2, wrap);
        result2.push(wrapped);
        match = match.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap;
      }
    });
    if (result2) {
      return { v: Fragment.from(result2) };
    }
  };
  for (var d = $context.depth; d >= 0; d--) {
    var returned = loop(d);
    if (returned)
      return returned.v;
  }
  return fragment;
}
function withWrappers(node2, wrap, from2) {
  if (from2 === void 0)
    from2 = 0;
  for (var i = wrap.length - 1; i >= from2; i--) {
    node2 = wrap[i].create(null, Fragment.from(node2));
  }
  return node2;
}
function addToSibling(wrap, lastWrap, node2, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node2, sibling.lastChild, depth + 1);
    if (inner) {
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    }
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node2.type : wrap[depth + 1])) {
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node2, wrap, depth + 1))));
    }
  }
}
function closeRight(node2, depth) {
  if (depth == 0) {
    return node2;
  }
  var fragment = node2.content.replaceChild(node2.childCount - 1, closeRight(node2.lastChild, depth - 1));
  var fill = node2.contentMatchAt(node2.childCount).fillBefore(Fragment.empty, true);
  return node2.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  var node2 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node2.content;
  if (depth < to - 1) {
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  }
  if (depth >= from2) {
    inner = side < 0 ? node2.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node2.contentMatchAt(node2.childCount).fillBefore(Fragment.empty, true));
  }
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node2.copy(inner));
}
function closeSlice(slice, openStart, openEnd) {
  if (openStart < slice.openStart) {
    slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
  }
  if (openEnd < slice.openEnd) {
    slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
  }
  return slice;
}
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas) {
    html = html.slice(metas[0].length);
  }
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {
    html = wrap.map(function(n) {
      return "<" + n + ">";
    }).join("") + html + wrap.map(function(n) {
      return "</" + n + ">";
    }).reverse().join("");
  }
  elt.innerHTML = html;
  if (wrap) {
    for (var i = 0; i < wrap.length; i++) {
      elt = elt.querySelector(wrap[i]) || elt;
    }
  }
  return elt;
}
function addContext(slice, context) {
  if (!slice.size) {
    return slice;
  }
  var schema = slice.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice;
  }
  var content = slice.content;
  var openStart = slice.openStart;
  var openEnd = slice.openEnd;
  for (var i = array.length - 2; i >= 0; i -= 2) {
    var type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) {
      break;
    }
    content = Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
function checkCSS(view) {
  if (cssChecked) {
    return;
  }
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal") {
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
  }
}
function initInput(view) {
  view.shiftKey = false;
  view.mouseDown = null;
  view.lastKeyCode = null;
  view.lastKeyCodeTime = 0;
  view.lastClick = { time: 0, x: 0, y: 0, type: "" };
  view.lastSelectionOrigin = null;
  view.lastSelectionTime = 0;
  view.lastIOSEnter = 0;
  view.lastIOSEnterFallbackTimeout = null;
  view.lastAndroidDelete = 0;
  view.composing = false;
  view.composingTimeout = null;
  view.compositionNodes = [];
  view.compositionEndedAt = -2e8;
  view.domObserver = new DOMObserver(view, function(from2, to, typeOver, added) {
    return readDOMChange(view, from2, to, typeOver, added);
  });
  view.domObserver.start();
  view.domChangeCount = 0;
  view.eventHandlers = Object.create(null);
  var loop = function(event2) {
    var handler = handlers[event2];
    view.dom.addEventListener(event2, view.eventHandlers[event2] = function(event3) {
      if (eventBelongsToView(view, event3) && !runCustomHandler(view, event3) && (view.editable || !(event3.type in editHandlers))) {
        handler(view, event3);
      }
    });
  };
  for (var event in handlers)
    loop(event);
  if (result.safari) {
    view.dom.addEventListener("input", function() {
      return null;
    });
  }
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.lastSelectionOrigin = origin;
  view.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (var type in view.eventHandlers) {
    view.dom.removeEventListener(type, view.eventHandlers[type]);
  }
  clearTimeout(view.composingTimeout);
  clearTimeout(view.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", function(currentHandlers) {
    for (var type in currentHandlers) {
      if (!view.eventHandlers[type]) {
        view.dom.addEventListener(type, view.eventHandlers[type] = function(event) {
          return runCustomHandler(view, event);
        });
      }
    }
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function(handlers2) {
    var handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles) {
    return true;
  }
  if (event.defaultPrevented) {
    return false;
  }
  for (var node2 = event.target; node2 != view.dom; node2 = node2.parentNode) {
    if (!node2 || node2.nodeType == 11 || node2.pmViewDesc && node2.pmViewDesc.stopEvent(event)) {
      return false;
    }
  }
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) {
    handlers[event.type](view, event);
  }
}
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside);
  var loop = function(i2) {
    if (view.someProp(propName, function(f) {
      return i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false);
    })) {
      return { v: true };
    }
  };
  for (var i = $pos.depth + 1; i > 0; i--) {
    var returned = loop(i);
    if (returned)
      return returned.v;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused) {
    view.focus();
  }
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") {
    tr.setMeta("pointer", true);
  }
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside), node2 = $pos.nodeAfter;
  if (node2 && node2.isAtom && NodeSelection.isSelectable(node2)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1) {
    return false;
  }
  var sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection) {
    selectedNode = sel.node;
  }
  var $pos = view.state.doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node2 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node2)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
        selectAt = $pos.before(sel.$from.depth);
      } else {
        selectAt = $pos.before(i);
      }
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f) {
    return f(view, pos, event);
  }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f) {
    return f(view, pos, event);
  });
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f) {
    return f(view, pos, event);
  }) || defaultTripleClick(view, inside);
}
function defaultTripleClick(view, inside) {
  var doc = view.state.doc;
  if (inside == -1) {
    if (doc.inlineContent) {
      updateSelection(view, TextSelection.create(doc, 0, doc.content.size), "pointer");
      return true;
    }
    return false;
  }
  var $pos = doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node2 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node2.inlineContent) {
      updateSelection(view, TextSelection.create(doc, nodePos + 1, nodePos + 1 + node2.content.size), "pointer");
    } else if (NodeSelection.isSelectable(node2)) {
      updateSelection(view, NodeSelection.create(doc, nodePos), "pointer");
    } else {
      continue;
    }
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
function inOrNearComposition(view, event) {
  if (view.composing) {
    return true;
  }
  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
    view.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.composingTimeout);
  if (delay > -1) {
    view.composingTimeout = setTimeout(function() {
      return endComposition(view);
    }, delay);
  }
}
function clearComposition(view) {
  view.composing = false;
  while (view.compositionNodes.length > 0) {
    view.compositionNodes.pop().markParentsDirty();
  }
}
function endComposition(view, forceUpdate) {
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) {
      view.dispatch(view.state.tr.setSelection(sel));
    } else {
      view.updateState(view.state);
    }
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode) {
    return;
  }
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function() {
    if (wrap.parentNode) {
      wrap.parentNode.removeChild(wrap);
    }
    view.focus();
  }, 50);
}
function sliceSingleNode(slice) {
  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
}
function capturePaste(view, e) {
  if (!view.dom.parentNode) {
    return;
  }
  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) {
    target.contentEditable = "true";
  }
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function() {
    view.focus();
    if (target.parentNode) {
      target.parentNode.removeChild(target);
    }
    if (plainText) {
      doPaste(view, target.value, null, e);
    } else {
      doPaste(view, target.textContent, target.innerHTML, e);
    }
  }, 50);
}
function doPaste(view, text, html, e) {
  var slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function(f) {
    return f(view, e, slice || Slice.empty);
  })) {
    return true;
  }
  if (!slice) {
    return false;
  }
  var singleNode = sliceSingleNode(slice);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function compareObjs(a, b) {
  if (a == b) {
    return true;
  }
  for (var p in a) {
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (var p$1 in b) {
    if (!(p$1 in a)) {
      return false;
    }
  }
  return true;
}
function mapChildren(oldChildren, newLocal, mapping, node2, offset, oldOffset, options) {
  var children = oldChildren.slice();
  var shift = function(oldStart, oldEnd, newStart, newEnd) {
    for (var i2 = 0; i2 < children.length; i2 += 3) {
      var end = children[i2 + 1], dSize = void 0;
      if (end == -1 || oldStart > end + oldOffset) {
        continue;
      }
      if (oldEnd >= children[i2] + oldOffset) {
        children[i2 + 1] = -1;
      } else if (newStart >= offset && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
        children[i2] += dSize;
        children[i2 + 1] += dSize;
      }
    }
  };
  for (var i = 0; i < mapping.maps.length; i++) {
    mapping.maps[i].forEach(shift);
  }
  var mustRebuild = false;
  for (var i$1 = 0; i$1 < children.length; i$1 += 3) {
    if (children[i$1 + 1] == -1) {
      var from2 = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from2 - offset;
      if (fromLocal < 0 || fromLocal >= node2.content.size) {
        mustRebuild = true;
        continue;
      }
      var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset;
      var ref = node2.content.findIndex(fromLocal);
      var index = ref.index;
      var childOffset = ref.offset;
      var childNode = node2.maybeChild(index);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[i$1 + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i$1] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i$1] = fromLocal;
          children[i$1 + 1] = toLocal;
          children[i$1 + 2] = mapped;
        } else {
          children[i$1 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  }
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping, offset, oldOffset, options);
    var built = buildTree(decorations, node2, 0, options);
    newLocal = built.local;
    for (var i$2 = 0; i$2 < children.length; i$2 += 3) {
      if (children[i$2 + 1] < 0) {
        children.splice(i$2, 3);
        i$2 -= 3;
      }
    }
    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j < children.length && children[j] < from$1) {
        j += 3;
      }
      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }
  return new DecorationSet(newLocal && newLocal.sort(byPos), children);
}
function moveSpans(spans, offset) {
  if (!offset || !spans.length) {
    return spans;
  }
  var result2 = [];
  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result2.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  function gather(set2, oldOffset2) {
    for (var i2 = 0; i2 < set2.local.length; i2++) {
      var mapped = set2.local[i2].map(mapping, offset, oldOffset2);
      if (mapped) {
        decorations.push(mapped);
      } else if (options.onRemove) {
        options.onRemove(set2.local[i2].spec);
      }
    }
    for (var i$1 = 0; i$1 < set2.children.length; i$1 += 3) {
      gather(set2.children[i$1 + 2], set2.children[i$1] + oldOffset2 + 1);
    }
  }
  for (var i = 0; i < children.length; i += 3) {
    if (children[i + 1] == -1) {
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
    }
  }
  return decorations;
}
function takeSpansForNode(spans, node2, offset) {
  if (node2.isLeaf) {
    return null;
  }
  var end = offset + node2.nodeSize, found = null;
  for (var i = 0, span = void 0; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset && span.to < end) {
      (found || (found = [])).push(span);
      spans[i] = null;
    }
  }
  return found;
}
function withoutNulls(array) {
  var result2 = [];
  for (var i = 0; i < array.length; i++) {
    if (array[i] != null) {
      result2.push(array[i]);
    }
  }
  return result2;
}
function buildTree(spans, node2, offset, options) {
  var children = [], hasNulls = false;
  node2.forEach(function(childNode, localStart) {
    var found = takeSpansForNode(spans, childNode, localStart + offset);
    if (found) {
      hasNulls = true;
      var subtree = buildTree(found, childNode, offset + localStart + 1, options);
      if (subtree != empty) {
        children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    }
  });
  var locals3 = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
  for (var i = 0; i < locals3.length; i++) {
    if (!locals3[i].type.valid(node2, locals3[i])) {
      if (options.onRemove) {
        options.onRemove(locals3[i].spec);
      }
      locals3.splice(i--, 1);
    }
  }
  return locals3.length || children.length ? new DecorationSet(locals3, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  var working = spans;
  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) {
      for (var j = i + 1; j < working.length; j++) {
        var next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
    }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0) {
    i++;
  }
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  var found = [];
  view.someProp("decorations", function(f) {
    var result2 = f(view.state);
    if (result2 && result2 != empty) {
      found.push(result2);
    }
  });
  if (view.cursorWrapper) {
    found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  }
  return DecorationGroup.from(found);
}
function computeDocDeco(view) {
  var attrs = Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", function(value) {
    if (typeof value == "function") {
      value = value(view.state);
    }
    if (value) {
      for (var attr in value) {
        if (attr == "class") {
          attrs.class += " " + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
          attrs[attr] = String(value[attr]);
        }
      }
    }
  });
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.setAttribute("mark-placeholder", "true");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", function(value) {
    return value(view.state) === false;
  });
}
function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  var result2 = {};
  view.someProp("nodeViews", function(obj) {
    for (var prop in obj) {
      if (!Object.prototype.hasOwnProperty.call(result2, prop)) {
        result2[prop] = obj[prop];
      }
    }
  });
  return result2;
}
function changedNodeViews(a, b) {
  var nA = 0, nB = 0;
  for (var prop in a) {
    if (a[prop] != b[prop]) {
      return true;
    }
    nA++;
  }
  for (var _ in b) {
    nB++;
  }
  return nA != nB;
}
var result, ie_edge, ie_upto10, ie_11up, ie, chrome, domIndex, parentNode, reusedRange, textRange, isEquivalentPosition, atomElements, selectionCollapsed, preventScrollSupported, BIDI, maybeRTL, cachedState, cachedDir, cachedResult, NOT_DIRTY, CHILD_DIRTY, CONTENT_DIRTY, NODE_DIRTY, ViewDesc, prototypeAccessors, nothing, WidgetViewDesc, CompositionViewDesc, MarkViewDesc, NodeViewDesc, TextViewDesc, BRHackViewDesc, CustomNodeViewDesc, noDeco, ViewTreeUpdater, brokenSelectBetweenUneditable, wrapMap, _detachedDoc, observeOptions, useCharData, SelectionState, DOMObserver, cssChecked, handlers, editHandlers, selectNodeModifier, MouseDown, timeoutComposition, brokenClipboardAPI, Dragging, dragCopyModifier, prop, WidgetType, InlineType, NodeType, Decoration, prototypeAccessors$1, none, noSpec, DecorationSet, empty, DecorationGroup, EditorView, prototypeAccessors$2;
var init_index_es5 = __esm({
  "../node_modules/prosemirror-tables/node_modules/prosemirror-view/dist/index.es.js"() {
    init_index_es3();
    init_index_es();
    init_index_es2();
    result = {};
    if (typeof navigator != "undefined" && typeof document != "undefined") {
      ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
      ie_upto10 = /MSIE \d/.test(navigator.userAgent);
      ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
      result.mac = /Mac/.test(navigator.platform);
      ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
      result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
      result.gecko = !ie && /gecko\/(\d+)/i.test(navigator.userAgent);
      result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
      chrome = !ie && /Chrome\/(\d+)/.exec(navigator.userAgent);
      result.chrome = !!chrome;
      result.chrome_version = chrome && +chrome[1];
      result.safari = !ie && /Apple Computer/.test(navigator.vendor);
      result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
      result.android = /Android \d/.test(navigator.userAgent);
      result.webkit = "webkitFontSmoothing" in document.documentElement.style;
      result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
    }
    domIndex = function(node2) {
      for (var index = 0; ; index++) {
        node2 = node2.previousSibling;
        if (!node2) {
          return index;
        }
      }
    };
    parentNode = function(node2) {
      var parent = node2.assignedSlot || node2.parentNode;
      return parent && parent.nodeType == 11 ? parent.host : parent;
    };
    reusedRange = null;
    textRange = function(node2, from2, to) {
      var range = reusedRange || (reusedRange = document.createRange());
      range.setEnd(node2, to == null ? node2.nodeValue.length : to);
      range.setStart(node2, from2 || 0);
      return range;
    };
    isEquivalentPosition = function(node2, off, targetNode, targetOff) {
      return targetNode && (scanFor(node2, off, targetNode, targetOff, -1) || scanFor(node2, off, targetNode, targetOff, 1));
    };
    atomElements = /^(img|br|input|textarea|hr)$/i;
    selectionCollapsed = function(domSel) {
      var collapsed = domSel.isCollapsed;
      if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
        collapsed = false;
      }
      return collapsed;
    };
    preventScrollSupported = null;
    BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    maybeRTL = /[\u0590-\u08ac]/;
    cachedState = null;
    cachedDir = null;
    cachedResult = false;
    NOT_DIRTY = 0;
    CHILD_DIRTY = 1;
    CONTENT_DIRTY = 2;
    NODE_DIRTY = 3;
    ViewDesc = function ViewDesc2(parent, children, dom, contentDOM) {
      this.parent = parent;
      this.children = children;
      this.dom = dom;
      dom.pmViewDesc = this;
      this.contentDOM = contentDOM;
      this.dirty = NOT_DIRTY;
    };
    prototypeAccessors = { beforePosition: { configurable: true }, size: { configurable: true }, border: { configurable: true }, posBefore: { configurable: true }, posAtStart: { configurable: true }, posAfter: { configurable: true }, posAtEnd: { configurable: true }, contentLost: { configurable: true }, domAtom: { configurable: true } };
    ViewDesc.prototype.matchesWidget = function matchesWidget() {
      return false;
    };
    ViewDesc.prototype.matchesMark = function matchesMark() {
      return false;
    };
    ViewDesc.prototype.matchesNode = function matchesNode() {
      return false;
    };
    ViewDesc.prototype.matchesHack = function matchesHack() {
      return false;
    };
    prototypeAccessors.beforePosition.get = function() {
      return false;
    };
    ViewDesc.prototype.parseRule = function parseRule() {
      return null;
    };
    ViewDesc.prototype.stopEvent = function stopEvent() {
      return false;
    };
    prototypeAccessors.size.get = function() {
      var size = 0;
      for (var i = 0; i < this.children.length; i++) {
        size += this.children[i].size;
      }
      return size;
    };
    prototypeAccessors.border.get = function() {
      return 0;
    };
    ViewDesc.prototype.destroy = function destroy() {
      this.parent = null;
      if (this.dom.pmViewDesc == this) {
        this.dom.pmViewDesc = null;
      }
      for (var i = 0; i < this.children.length; i++) {
        this.children[i].destroy();
      }
    };
    ViewDesc.prototype.posBeforeChild = function posBeforeChild(child) {
      for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
        var cur = this.children[i];
        if (cur == child) {
          return pos;
        }
        pos += cur.size;
      }
    };
    prototypeAccessors.posBefore.get = function() {
      return this.parent.posBeforeChild(this);
    };
    prototypeAccessors.posAtStart.get = function() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    };
    prototypeAccessors.posAfter.get = function() {
      return this.posBefore + this.size;
    };
    prototypeAccessors.posAtEnd.get = function() {
      return this.posAtStart + this.size - 2 * this.border;
    };
    ViewDesc.prototype.localPosFromDOM = function localPosFromDOM(dom, offset, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          var domBefore, desc;
          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset - 1];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }
            domBefore = dom.previousSibling;
          }
          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
            domBefore = domBefore.previousSibling;
          }
          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          var domAfter, desc$1;
          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }
            domAfter = dom.nextSibling;
          }
          while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
            domAfter = domAfter.nextSibling;
          }
          return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
        }
      }
      var atEnd;
      if (dom == this.dom && this.contentDOM) {
        atEnd = offset > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset == 0) {
          for (var search = dom; ; search = search.parentNode) {
            if (search == this.dom) {
              atEnd = false;
              break;
            }
            if (search.parentNode.firstChild != search) {
              break;
            }
          }
        }
        if (atEnd == null && offset == dom.childNodes.length) {
          for (var search$1 = dom; ; search$1 = search$1.parentNode) {
            if (search$1 == this.dom) {
              atEnd = true;
              break;
            }
            if (search$1.parentNode.lastChild != search$1) {
              break;
            }
          }
        }
      }
      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    };
    ViewDesc.prototype.nearestDesc = function nearestDesc(dom, onlyNodes) {
      for (var first = true, cur = dom; cur; cur = cur.parentNode) {
        var desc = this.getDesc(cur);
        if (desc && (!onlyNodes || desc.node)) {
          if (first && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom)) {
            first = false;
          } else {
            return desc;
          }
        }
      }
    };
    ViewDesc.prototype.getDesc = function getDesc(dom) {
      var desc = dom.pmViewDesc;
      for (var cur = desc; cur; cur = cur.parent) {
        if (cur == this) {
          return desc;
        }
      }
    };
    ViewDesc.prototype.posFromDOM = function posFromDOM(dom, offset, bias) {
      for (var scan = dom; scan; scan = scan.parentNode) {
        var desc = this.getDesc(scan);
        if (desc) {
          return desc.localPosFromDOM(dom, offset, bias);
        }
      }
      return -1;
    };
    ViewDesc.prototype.descAt = function descAt(pos) {
      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i], end = offset + child.size;
        if (offset == pos && end != offset) {
          while (!child.border && child.children.length) {
            child = child.children[0];
          }
          return child;
        }
        if (pos < end) {
          return child.descAt(pos - offset - child.border);
        }
        offset = end;
      }
    };
    ViewDesc.prototype.domFromPos = function domFromPos(pos, side) {
      if (!this.contentDOM) {
        return { node: this.dom, offset: 0 };
      }
      for (var offset = 0, i = 0, first = true; ; i++, first = false) {
        while (i < this.children.length && (this.children[i].beforePosition || this.children[i].dom.parentNode != this.contentDOM)) {
          offset += this.children[i++].size;
        }
        var child = i == this.children.length ? null : this.children[i];
        if (offset == pos && (side == 0 || !child || !child.size || child.border || side < 0 && first) || child && child.domAtom && pos < offset + child.size) {
          return {
            node: this.contentDOM,
            offset: child ? domIndex(child.dom) : this.contentDOM.childNodes.length
          };
        }
        if (!child) {
          throw new Error("Invalid position " + pos);
        }
        var end = offset + child.size;
        if (!child.domAtom && (side < 0 && !child.border ? end >= pos : end > pos) && (end > pos || i + 1 >= this.children.length || !this.children[i + 1].beforePosition)) {
          return child.domFromPos(pos - offset - child.border, side);
        }
        offset = end;
      }
    };
    ViewDesc.prototype.parseRange = function parseRange(from2, to, base) {
      if (base === void 0)
        base = 0;
      if (this.children.length == 0) {
        return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
      }
      var fromOffset = -1, toOffset = -1;
      for (var offset = base, i = 0; ; i++) {
        var child = this.children[i], end = offset + child.size;
        if (fromOffset == -1 && from2 <= end) {
          var childBase = offset + child.border;
          if (from2 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) {
            return child.parseRange(from2, to, childBase);
          }
          from2 = offset;
          for (var j = i; j > 0; j--) {
            var prev = this.children[j - 1];
            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }
            from2 -= prev.size;
          }
          if (fromOffset == -1) {
            fromOffset = 0;
          }
        }
        if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
          to = end;
          for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
            var next = this.children[j$1];
            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }
            to += next.size;
          }
          if (toOffset == -1) {
            toOffset = this.contentDOM.childNodes.length;
          }
          break;
        }
        offset = end;
      }
      return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
    };
    ViewDesc.prototype.emptyChildAt = function emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length) {
        return false;
      }
      var child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    };
    ViewDesc.prototype.domAfterPos = function domAfterPos(pos) {
      var ref = this.domFromPos(pos, 0);
      var node2 = ref.node;
      var offset = ref.offset;
      if (node2.nodeType != 1 || offset == node2.childNodes.length) {
        throw new RangeError("No node after pos " + pos);
      }
      return node2.childNodes[offset];
    };
    ViewDesc.prototype.setSelection = function setSelection(anchor, head, root, force) {
      var from2 = Math.min(anchor, head), to = Math.max(anchor, head);
      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i], end = offset + child.size;
        if (from2 > offset && to < end) {
          return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);
        }
        offset = end;
      }
      var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      var domSel = root.getSelection();
      var brKludge = false;
      if ((result.gecko || result.safari) && anchor == head) {
        var node2 = anchorDOM.node;
        var offset$1 = anchorDOM.offset;
        if (node2.nodeType == 3) {
          brKludge = offset$1 && node2.nodeValue[offset$1 - 1] == "\n";
          if (brKludge && offset$1 == node2.nodeValue.length && node2.nextSibling && node2.nextSibling.nodeName == "BR") {
            anchorDOM = headDOM = { node: node2.parentNode, offset: domIndex(node2) + 1 };
          }
        } else {
          var prev = node2.childNodes[offset$1 - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }
      if (!(force || brKludge && result.safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
        return;
      }
      var domSelExtended = false;
      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);
        try {
          if (anchor != head) {
            domSel.extend(headDOM.node, headDOM.offset);
          }
          domSelExtended = true;
        } catch (err) {
          if (!(err instanceof DOMException)) {
            throw err;
          }
        }
      }
      if (!domSelExtended) {
        if (anchor > head) {
          var tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }
        var range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    };
    ViewDesc.prototype.ignoreMutation = function ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    };
    prototypeAccessors.contentLost.get = function() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    };
    ViewDesc.prototype.markDirty = function markDirty(from2, to) {
      for (var offset = 0, i = 0; i < this.children.length; i++) {
        var child = this.children[i], end = offset + child.size;
        if (offset == end ? from2 <= end && to >= offset : from2 < end && to > offset) {
          var startInside = offset + child.border, endInside = end - child.border;
          if (from2 >= startInside && to <= endInside) {
            this.dirty = from2 == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) {
              child.dirty = NODE_DIRTY;
            } else {
              child.markDirty(from2 - startInside, to - startInside);
            }
            return;
          } else {
            child.dirty = NODE_DIRTY;
          }
        }
        offset = end;
      }
      this.dirty = CONTENT_DIRTY;
    };
    ViewDesc.prototype.markParentsDirty = function markParentsDirty() {
      var level = 1;
      for (var node2 = this.parent; node2; node2 = node2.parent, level++) {
        var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node2.dirty < dirty) {
          node2.dirty = dirty;
        }
      }
    };
    prototypeAccessors.domAtom.get = function() {
      return false;
    };
    Object.defineProperties(ViewDesc.prototype, prototypeAccessors);
    nothing = [];
    WidgetViewDesc = function(ViewDesc3) {
      function WidgetViewDesc2(parent, widget2, view, pos) {
        var self, dom = widget2.type.toDOM;
        if (typeof dom == "function") {
          dom = dom(view, function() {
            if (!self) {
              return pos;
            }
            if (self.parent) {
              return self.parent.posBeforeChild(self);
            }
          });
        }
        if (!widget2.type.spec.raw) {
          if (dom.nodeType != 1) {
            var wrap = document.createElement("span");
            wrap.appendChild(dom);
            dom = wrap;
          }
          dom.contentEditable = false;
          dom.classList.add("ProseMirror-widget");
        }
        ViewDesc3.call(this, parent, nothing, dom, null);
        this.widget = widget2;
        self = this;
      }
      if (ViewDesc3)
        WidgetViewDesc2.__proto__ = ViewDesc3;
      WidgetViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
      WidgetViewDesc2.prototype.constructor = WidgetViewDesc2;
      var prototypeAccessors$12 = { beforePosition: { configurable: true }, domAtom: { configurable: true } };
      prototypeAccessors$12.beforePosition.get = function() {
        return this.widget.type.side < 0;
      };
      WidgetViewDesc2.prototype.matchesWidget = function matchesWidget2(widget2) {
        return this.dirty == NOT_DIRTY && widget2.type.eq(this.widget.type);
      };
      WidgetViewDesc2.prototype.parseRule = function parseRule2() {
        return { ignore: true };
      };
      WidgetViewDesc2.prototype.stopEvent = function stopEvent2(event) {
        var stop2 = this.widget.spec.stopEvent;
        return stop2 ? stop2(event) : false;
      };
      WidgetViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
        return mutation.type != "selection" || this.widget.spec.ignoreSelection;
      };
      prototypeAccessors$12.domAtom.get = function() {
        return true;
      };
      Object.defineProperties(WidgetViewDesc2.prototype, prototypeAccessors$12);
      return WidgetViewDesc2;
    }(ViewDesc);
    CompositionViewDesc = function(ViewDesc3) {
      function CompositionViewDesc2(parent, dom, textDOM, text) {
        ViewDesc3.call(this, parent, nothing, dom, null);
        this.textDOM = textDOM;
        this.text = text;
      }
      if (ViewDesc3)
        CompositionViewDesc2.__proto__ = ViewDesc3;
      CompositionViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
      CompositionViewDesc2.prototype.constructor = CompositionViewDesc2;
      var prototypeAccessors$22 = { size: { configurable: true } };
      prototypeAccessors$22.size.get = function() {
        return this.text.length;
      };
      CompositionViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset) {
        if (dom != this.textDOM) {
          return this.posAtStart + (offset ? this.size : 0);
        }
        return this.posAtStart + offset;
      };
      CompositionViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
        return { node: this.textDOM, offset: pos };
      };
      CompositionViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mut) {
        return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
      };
      Object.defineProperties(CompositionViewDesc2.prototype, prototypeAccessors$22);
      return CompositionViewDesc2;
    }(ViewDesc);
    MarkViewDesc = function(ViewDesc3) {
      function MarkViewDesc2(parent, mark, dom, contentDOM) {
        ViewDesc3.call(this, parent, [], dom, contentDOM);
        this.mark = mark;
      }
      if (ViewDesc3)
        MarkViewDesc2.__proto__ = ViewDesc3;
      MarkViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
      MarkViewDesc2.prototype.constructor = MarkViewDesc2;
      MarkViewDesc2.create = function create2(parent, mark, inline2, view) {
        var custom = view.nodeViews[mark.type.name];
        var spec = custom && custom(mark, view, inline2);
        if (!spec || !spec.dom) {
          spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline2));
        }
        return new MarkViewDesc2(parent, mark, spec.dom, spec.contentDOM || spec.dom);
      };
      MarkViewDesc2.prototype.parseRule = function parseRule2() {
        return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
      };
      MarkViewDesc2.prototype.matchesMark = function matchesMark2(mark) {
        return this.dirty != NODE_DIRTY && this.mark.eq(mark);
      };
      MarkViewDesc2.prototype.markDirty = function markDirty2(from2, to) {
        ViewDesc3.prototype.markDirty.call(this, from2, to);
        if (this.dirty != NOT_DIRTY) {
          var parent = this.parent;
          while (!parent.node) {
            parent = parent.parent;
          }
          if (parent.dirty < this.dirty) {
            parent.dirty = this.dirty;
          }
          this.dirty = NOT_DIRTY;
        }
      };
      MarkViewDesc2.prototype.slice = function slice(from2, to, view) {
        var copy2 = MarkViewDesc2.create(this.parent, this.mark, true, view);
        var nodes = this.children, size = this.size;
        if (to < size) {
          nodes = replaceNodes(nodes, to, size, view);
        }
        if (from2 > 0) {
          nodes = replaceNodes(nodes, 0, from2, view);
        }
        for (var i = 0; i < nodes.length; i++) {
          nodes[i].parent = copy2;
        }
        copy2.children = nodes;
        return copy2;
      };
      return MarkViewDesc2;
    }(ViewDesc);
    NodeViewDesc = function(ViewDesc3) {
      function NodeViewDesc2(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos) {
        ViewDesc3.call(this, parent, node2.isLeaf ? nothing : [], dom, contentDOM);
        this.nodeDOM = nodeDOM2;
        this.node = node2;
        this.outerDeco = outerDeco;
        this.innerDeco = innerDeco;
        if (contentDOM) {
          this.updateChildren(view, pos);
        }
      }
      if (ViewDesc3)
        NodeViewDesc2.__proto__ = ViewDesc3;
      NodeViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
      NodeViewDesc2.prototype.constructor = NodeViewDesc2;
      var prototypeAccessors$3 = { size: { configurable: true }, border: { configurable: true }, domAtom: { configurable: true } };
      NodeViewDesc2.create = function create2(parent, node2, outerDeco, innerDeco, view, pos) {
        var assign;
        var custom = view.nodeViews[node2.type.name], descObj;
        var spec = custom && custom(node2, view, function() {
          if (!descObj) {
            return pos;
          }
          if (descObj.parent) {
            return descObj.parent.posBeforeChild(descObj);
          }
        }, outerDeco, innerDeco);
        var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
        if (node2.isText) {
          if (!dom) {
            dom = document.createTextNode(node2.text);
          } else if (dom.nodeType != 3) {
            throw new RangeError("Text must be rendered as a DOM text node");
          }
        } else if (!dom) {
          assign = DOMSerializer.renderSpec(document, node2.type.spec.toDOM(node2)), dom = assign.dom, contentDOM = assign.contentDOM;
        }
        if (!contentDOM && !node2.isText && dom.nodeName != "BR") {
          if (!dom.hasAttribute("contenteditable")) {
            dom.contentEditable = false;
          }
          if (node2.type.spec.draggable) {
            dom.draggable = true;
          }
        }
        var nodeDOM2 = dom;
        dom = applyOuterDeco(dom, outerDeco, node2);
        if (spec) {
          return descObj = new CustomNodeViewDesc(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, spec, view, pos + 1);
        } else if (node2.isText) {
          return new TextViewDesc(parent, node2, outerDeco, innerDeco, dom, nodeDOM2, view);
        } else {
          return new NodeViewDesc2(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos + 1);
        }
      };
      NodeViewDesc2.prototype.parseRule = function parseRule2() {
        var this$1 = this;
        if (this.node.type.spec.reparseInView) {
          return null;
        }
        var rule = { node: this.node.type.name, attrs: this.node.attrs };
        if (this.node.type.spec.code) {
          rule.preserveWhitespace = "full";
        }
        if (this.contentDOM && !this.contentLost) {
          rule.contentElement = this.contentDOM;
        } else {
          rule.getContent = function() {
            return this$1.contentDOM ? Fragment.empty : this$1.node.content;
          };
        }
        return rule;
      };
      NodeViewDesc2.prototype.matchesNode = function matchesNode2(node2, outerDeco, innerDeco) {
        return this.dirty == NOT_DIRTY && node2.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
      };
      prototypeAccessors$3.size.get = function() {
        return this.node.nodeSize;
      };
      prototypeAccessors$3.border.get = function() {
        return this.node.isLeaf ? 0 : 1;
      };
      NodeViewDesc2.prototype.updateChildren = function updateChildren(view, pos) {
        var this$1 = this;
        var inline2 = this.node.inlineContent, off = pos;
        var composition = inline2 && view.composing && this.localCompositionNode(view, pos);
        var updater = new ViewTreeUpdater(this, composition && composition.node);
        iterDeco(this.node, this.innerDeco, function(widget2, i, insideNode) {
          if (widget2.spec.marks) {
            updater.syncToMarks(widget2.spec.marks, inline2, view);
          } else if (widget2.type.side >= 0 && !insideNode) {
            updater.syncToMarks(i == this$1.node.childCount ? Mark.none : this$1.node.child(i).marks, inline2, view);
          }
          updater.placeWidget(widget2, view, off);
        }, function(child, outerDeco, innerDeco, i) {
          updater.syncToMarks(child.marks, inline2, view);
          updater.findNodeMatch(child, outerDeco, innerDeco, i) || updater.updateNextNode(child, outerDeco, innerDeco, view, i) || updater.addNode(child, outerDeco, innerDeco, view, off);
          off += child.nodeSize;
        });
        updater.syncToMarks(nothing, inline2, view);
        if (this.node.isTextblock) {
          updater.addTextblockHacks();
        }
        updater.destroyRest();
        if (updater.changed || this.dirty == CONTENT_DIRTY) {
          if (composition) {
            this.protectLocalComposition(view, composition);
          }
          renderDescs(this.contentDOM, this.children, view);
          if (result.ios) {
            iosHacks(this.dom);
          }
        }
      };
      NodeViewDesc2.prototype.localCompositionNode = function localCompositionNode(view, pos) {
        var ref = view.state.selection;
        var from2 = ref.from;
        var to = ref.to;
        if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size) {
          return;
        }
        var sel = view.root.getSelection();
        var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
        if (!textNode || !this.dom.contains(textNode.parentNode)) {
          return;
        }
        var text = textNode.nodeValue;
        var textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
        return textPos < 0 ? null : { node: textNode, pos: textPos, text };
      };
      NodeViewDesc2.prototype.protectLocalComposition = function protectLocalComposition(view, ref) {
        var node2 = ref.node;
        var pos = ref.pos;
        var text = ref.text;
        if (this.getDesc(node2)) {
          return;
        }
        var topNode = node2;
        for (; ; topNode = topNode.parentNode) {
          if (topNode.parentNode == this.contentDOM) {
            break;
          }
          while (topNode.previousSibling) {
            topNode.parentNode.removeChild(topNode.previousSibling);
          }
          while (topNode.nextSibling) {
            topNode.parentNode.removeChild(topNode.nextSibling);
          }
          if (topNode.pmViewDesc) {
            topNode.pmViewDesc = null;
          }
        }
        var desc = new CompositionViewDesc(this, topNode, node2, text);
        view.compositionNodes.push(desc);
        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
      };
      NodeViewDesc2.prototype.update = function update3(node2, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY || !node2.sameMarkup(this.node)) {
          return false;
        }
        this.updateInner(node2, outerDeco, innerDeco, view);
        return true;
      };
      NodeViewDesc2.prototype.updateInner = function updateInner(node2, outerDeco, innerDeco, view) {
        this.updateOuterDeco(outerDeco);
        this.node = node2;
        this.innerDeco = innerDeco;
        if (this.contentDOM) {
          this.updateChildren(view, this.posAtStart);
        }
        this.dirty = NOT_DIRTY;
      };
      NodeViewDesc2.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
        if (sameOuterDeco(outerDeco, this.outerDeco)) {
          return;
        }
        var needsWrap = this.nodeDOM.nodeType != 1;
        var oldDOM = this.dom;
        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
        if (this.dom != oldDOM) {
          oldDOM.pmViewDesc = null;
          this.dom.pmViewDesc = this;
        }
        this.outerDeco = outerDeco;
      };
      NodeViewDesc2.prototype.selectNode = function selectNode() {
        this.nodeDOM.classList.add("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable) {
          this.dom.draggable = true;
        }
      };
      NodeViewDesc2.prototype.deselectNode = function deselectNode() {
        this.nodeDOM.classList.remove("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable) {
          this.dom.removeAttribute("draggable");
        }
      };
      prototypeAccessors$3.domAtom.get = function() {
        return this.node.isAtom;
      };
      Object.defineProperties(NodeViewDesc2.prototype, prototypeAccessors$3);
      return NodeViewDesc2;
    }(ViewDesc);
    TextViewDesc = function(NodeViewDesc2) {
      function TextViewDesc2(parent, node2, outerDeco, innerDeco, dom, nodeDOM2, view) {
        NodeViewDesc2.call(this, parent, node2, outerDeco, innerDeco, dom, null, nodeDOM2, view);
      }
      if (NodeViewDesc2)
        TextViewDesc2.__proto__ = NodeViewDesc2;
      TextViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
      TextViewDesc2.prototype.constructor = TextViewDesc2;
      var prototypeAccessors$4 = { domAtom: { configurable: true } };
      TextViewDesc2.prototype.parseRule = function parseRule2() {
        var skip = this.nodeDOM.parentNode;
        while (skip && skip != this.dom && !skip.pmIsDeco) {
          skip = skip.parentNode;
        }
        return { skip: skip || true };
      };
      TextViewDesc2.prototype.update = function update3(node2, outerDeco, _, view) {
        if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node2.sameMarkup(this.node)) {
          return false;
        }
        this.updateOuterDeco(outerDeco);
        if ((this.dirty != NOT_DIRTY || node2.text != this.node.text) && node2.text != this.nodeDOM.nodeValue) {
          this.nodeDOM.nodeValue = node2.text;
          if (view.trackWrites == this.nodeDOM) {
            view.trackWrites = null;
          }
        }
        this.node = node2;
        this.dirty = NOT_DIRTY;
        return true;
      };
      TextViewDesc2.prototype.inParent = function inParent() {
        var parentDOM = this.parent.contentDOM;
        for (var n = this.nodeDOM; n; n = n.parentNode) {
          if (n == parentDOM) {
            return true;
          }
        }
        return false;
      };
      TextViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
        return { node: this.nodeDOM, offset: pos };
      };
      TextViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset, bias) {
        if (dom == this.nodeDOM) {
          return this.posAtStart + Math.min(offset, this.node.text.length);
        }
        return NodeViewDesc2.prototype.localPosFromDOM.call(this, dom, offset, bias);
      };
      TextViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
        return mutation.type != "characterData" && mutation.type != "selection";
      };
      TextViewDesc2.prototype.slice = function slice(from2, to, view) {
        var node2 = this.node.cut(from2, to), dom = document.createTextNode(node2.text);
        return new TextViewDesc2(this.parent, node2, this.outerDeco, this.innerDeco, dom, dom, view);
      };
      prototypeAccessors$4.domAtom.get = function() {
        return false;
      };
      Object.defineProperties(TextViewDesc2.prototype, prototypeAccessors$4);
      return TextViewDesc2;
    }(NodeViewDesc);
    BRHackViewDesc = function(ViewDesc3) {
      function BRHackViewDesc2() {
        ViewDesc3.apply(this, arguments);
      }
      if (ViewDesc3)
        BRHackViewDesc2.__proto__ = ViewDesc3;
      BRHackViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
      BRHackViewDesc2.prototype.constructor = BRHackViewDesc2;
      var prototypeAccessors$5 = { domAtom: { configurable: true } };
      BRHackViewDesc2.prototype.parseRule = function parseRule2() {
        return { ignore: true };
      };
      BRHackViewDesc2.prototype.matchesHack = function matchesHack2() {
        return this.dirty == NOT_DIRTY;
      };
      prototypeAccessors$5.domAtom.get = function() {
        return true;
      };
      Object.defineProperties(BRHackViewDesc2.prototype, prototypeAccessors$5);
      return BRHackViewDesc2;
    }(ViewDesc);
    CustomNodeViewDesc = function(NodeViewDesc2) {
      function CustomNodeViewDesc2(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, spec, view, pos) {
        NodeViewDesc2.call(this, parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos);
        this.spec = spec;
      }
      if (NodeViewDesc2)
        CustomNodeViewDesc2.__proto__ = NodeViewDesc2;
      CustomNodeViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
      CustomNodeViewDesc2.prototype.constructor = CustomNodeViewDesc2;
      CustomNodeViewDesc2.prototype.update = function update3(node2, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY) {
          return false;
        }
        if (this.spec.update) {
          var result2 = this.spec.update(node2, outerDeco, innerDeco);
          if (result2) {
            this.updateInner(node2, outerDeco, innerDeco, view);
          }
          return result2;
        } else if (!this.contentDOM && !node2.isLeaf) {
          return false;
        } else {
          return NodeViewDesc2.prototype.update.call(this, node2, outerDeco, innerDeco, view);
        }
      };
      CustomNodeViewDesc2.prototype.selectNode = function selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc2.prototype.selectNode.call(this);
      };
      CustomNodeViewDesc2.prototype.deselectNode = function deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc2.prototype.deselectNode.call(this);
      };
      CustomNodeViewDesc2.prototype.setSelection = function setSelection2(anchor, head, root, force) {
        this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : NodeViewDesc2.prototype.setSelection.call(this, anchor, head, root, force);
      };
      CustomNodeViewDesc2.prototype.destroy = function destroy3() {
        if (this.spec.destroy) {
          this.spec.destroy();
        }
        NodeViewDesc2.prototype.destroy.call(this);
      };
      CustomNodeViewDesc2.prototype.stopEvent = function stopEvent2(event) {
        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
      };
      CustomNodeViewDesc2.prototype.ignoreMutation = function ignoreMutation3(mutation) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
      };
      return CustomNodeViewDesc2;
    }(NodeViewDesc);
    OuterDecoLevel.prototype = Object.create(null);
    noDeco = [new OuterDecoLevel()];
    ViewTreeUpdater = function ViewTreeUpdater2(top, lockedNode) {
      this.top = top;
      this.lock = lockedNode;
      this.index = 0;
      this.stack = [];
      this.changed = false;
      this.preMatch = preMatch(top.node.content, top.children);
    };
    ViewTreeUpdater.prototype.destroyBetween = function destroyBetween(start2, end) {
      if (start2 == end) {
        return;
      }
      for (var i = start2; i < end; i++) {
        this.top.children[i].destroy();
      }
      this.top.children.splice(start2, end - start2);
      this.changed = true;
    };
    ViewTreeUpdater.prototype.destroyRest = function destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    };
    ViewTreeUpdater.prototype.syncToMarks = function syncToMarks(marks, inline2, view) {
      var keep = 0, depth = this.stack.length >> 1;
      var maxKeep = Math.min(depth, marks.length);
      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false) {
        keep++;
      }
      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }
      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        var found = -1;
        for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
          if (this.top.children[i].matchesMark(marks[depth])) {
            found = i;
            break;
          }
        }
        if (found > -1) {
          if (found > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found);
          }
          this.top = this.top.children[this.index];
        } else {
          var markDesc = MarkViewDesc.create(this.top, marks[depth], inline2, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }
        this.index = 0;
        depth++;
      }
    };
    ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch(node2, outerDeco, innerDeco, index) {
      var children = this.top.children, found = -1;
      if (index >= this.preMatch.index) {
        for (var i = this.index; i < children.length; i++) {
          if (children[i].matchesNode(node2, outerDeco, innerDeco)) {
            found = i;
            break;
          }
        }
      } else {
        for (var i$1 = this.index, e = Math.min(children.length, i$1 + 1); i$1 < e; i$1++) {
          var child = children[i$1];
          if (child.matchesNode(node2, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found = i$1;
            break;
          }
        }
      }
      if (found < 0) {
        return false;
      }
      this.destroyBetween(this.index, found);
      this.index++;
      return true;
    };
    ViewTreeUpdater.prototype.updateNextNode = function updateNextNode(node2, outerDeco, innerDeco, view, index) {
      for (var i = this.index; i < this.top.children.length; i++) {
        var next = this.top.children[i];
        if (next instanceof NodeViewDesc) {
          var preMatch2 = this.preMatch.matched.get(next);
          if (preMatch2 != null && preMatch2 != index) {
            return false;
          }
          var nextDOM = next.dom;
          var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node2.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node2.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
          if (!locked && next.update(node2, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i);
            if (next.dom != nextDOM) {
              this.changed = true;
            }
            this.index++;
            return true;
          }
          break;
        }
      }
      return false;
    };
    ViewTreeUpdater.prototype.addNode = function addNode(node2, outerDeco, innerDeco, view, pos) {
      this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node2, outerDeco, innerDeco, view, pos));
      this.changed = true;
    };
    ViewTreeUpdater.prototype.placeWidget = function placeWidget(widget2, view, pos) {
      var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (next && next.matchesWidget(widget2) && (widget2 == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        var desc = new WidgetViewDesc(this.top, widget2, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    };
    ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks() {
      var lastChild = this.top.children[this.index - 1];
      while (lastChild instanceof MarkViewDesc) {
        lastChild = lastChild.children[lastChild.children.length - 1];
      }
      if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
        if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {
          this.index++;
        } else {
          var dom = document.createElement("br");
          this.top.children.splice(this.index++, 0, new BRHackViewDesc(this.top, nothing, dom, null));
          this.changed = true;
        }
      }
    };
    brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;
    wrapMap = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    _detachedDoc = null;
    observeOptions = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    };
    useCharData = result.ie && result.ie_version <= 11;
    SelectionState = function SelectionState2() {
      this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
    };
    SelectionState.prototype.set = function set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    };
    SelectionState.prototype.eq = function eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    };
    DOMObserver = function DOMObserver2(view, handleDOMChange) {
      var this$1 = this;
      this.view = view;
      this.handleDOMChange = handleDOMChange;
      this.queue = [];
      this.flushingSoon = -1;
      this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
        for (var i = 0; i < mutations.length; i++) {
          this$1.queue.push(mutations[i]);
        }
        if (result.ie && result.ie_version <= 11 && mutations.some(function(m) {
          return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
        })) {
          this$1.flushSoon();
        } else {
          this$1.flush();
        }
      });
      this.currentSelection = new SelectionState();
      if (useCharData) {
        this.onCharData = function(e) {
          this$1.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
          this$1.flushSoon();
        };
      }
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.suppressingSelectionUpdates = false;
    };
    DOMObserver.prototype.flushSoon = function flushSoon() {
      var this$1 = this;
      if (this.flushingSoon < 0) {
        this.flushingSoon = window.setTimeout(function() {
          this$1.flushingSoon = -1;
          this$1.flush();
        }, 20);
      }
    };
    DOMObserver.prototype.forceFlush = function forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    };
    DOMObserver.prototype.start = function start() {
      if (this.observer) {
        this.observer.observe(this.view.dom, observeOptions);
      }
      if (useCharData) {
        this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      }
      this.connectSelection();
    };
    DOMObserver.prototype.stop = function stop() {
      var this$1 = this;
      if (this.observer) {
        var take = this.observer.takeRecords();
        if (take.length) {
          for (var i = 0; i < take.length; i++) {
            this.queue.push(take[i]);
          }
          window.setTimeout(function() {
            return this$1.flush();
          }, 20);
        }
        this.observer.disconnect();
      }
      if (useCharData) {
        this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      }
      this.disconnectSelection();
    };
    DOMObserver.prototype.connectSelection = function connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    };
    DOMObserver.prototype.disconnectSelection = function disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    };
    DOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates() {
      var this$1 = this;
      this.suppressingSelectionUpdates = true;
      setTimeout(function() {
        return this$1.suppressingSelectionUpdates = false;
      }, 50);
    };
    DOMObserver.prototype.onSelectionChange = function onSelectionChange() {
      if (!hasFocusAndSelection(this.view)) {
        return;
      }
      if (this.suppressingSelectionUpdates) {
        return selectionToDOM(this.view);
      }
      if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
        var sel = this.view.root.getSelection();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) {
          return this.flushSoon();
        }
      }
      this.flush();
    };
    DOMObserver.prototype.setCurSelection = function setCurSelection() {
      this.currentSelection.set(this.view.root.getSelection());
    };
    DOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange(sel) {
      if (sel.rangeCount == 0) {
        return true;
      }
      var container = sel.getRangeAt(0).commonAncestorContainer;
      var desc = this.view.docView.nearestDesc(container);
      if (desc && desc.ignoreMutation({ type: "selection", target: container.nodeType == 3 ? container.parentNode : container })) {
        this.setCurSelection();
        return true;
      }
    };
    DOMObserver.prototype.flush = function flush() {
      if (!this.view.docView || this.flushingSoon > -1) {
        return;
      }
      var mutations = this.observer ? this.observer.takeRecords() : [];
      if (this.queue.length) {
        mutations = this.queue.concat(mutations);
        this.queue.length = 0;
      }
      var sel = this.view.root.getSelection();
      var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);
      var from2 = -1, to = -1, typeOver = false, added = [];
      if (this.view.editable) {
        for (var i = 0; i < mutations.length; i++) {
          var result$1 = this.registerMutation(mutations[i], added);
          if (result$1) {
            from2 = from2 < 0 ? result$1.from : Math.min(result$1.from, from2);
            to = to < 0 ? result$1.to : Math.max(result$1.to, to);
            if (result$1.typeOver) {
              typeOver = true;
            }
          }
        }
      }
      if (result.gecko && added.length > 1) {
        var brs = added.filter(function(n) {
          return n.nodeName == "BR";
        });
        if (brs.length == 2) {
          var a = brs[0];
          var b = brs[1];
          if (a.parentNode && a.parentNode.parentNode == b.parentNode) {
            b.remove();
          } else {
            a.remove();
          }
        }
      }
      if (from2 > -1 || newSel) {
        if (from2 > -1) {
          this.view.docView.markDirty(from2, to);
          checkCSS(this.view);
        }
        this.handleDOMChange(from2, to, typeOver, added);
        if (this.view.docView.dirty) {
          this.view.updateState(this.view.state);
        } else if (!this.currentSelection.eq(sel)) {
          selectionToDOM(this.view);
        }
        this.currentSelection.set(sel);
      }
    };
    DOMObserver.prototype.registerMutation = function registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1) {
        return null;
      }
      var desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) {
        return null;
      }
      if (!desc || desc.ignoreMutation(mut)) {
        return null;
      }
      if (mut.type == "childList") {
        for (var i = 0; i < mut.addedNodes.length; i++) {
          added.push(mut.addedNodes[i]);
        }
        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) {
          return { from: desc.posBefore, to: desc.posAfter };
        }
        var prev = mut.previousSibling, next = mut.nextSibling;
        if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
          for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
            var ref = mut.addedNodes[i$1];
            var previousSibling = ref.previousSibling;
            var nextSibling = ref.nextSibling;
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) {
              prev = previousSibling;
            }
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) {
              next = nextSibling;
            }
          }
        }
        var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        var from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
        var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        var to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return { from: from2, to };
      } else if (mut.type == "attributes") {
        return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
      } else {
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    };
    cssChecked = false;
    handlers = {};
    editHandlers = {};
    editHandlers.keydown = function(view, event) {
      view.shiftKey = event.keyCode == 16 || event.shiftKey;
      if (inOrNearComposition(view, event)) {
        return;
      }
      view.domObserver.forceFlush();
      view.lastKeyCode = event.keyCode;
      view.lastKeyCodeTime = Date.now();
      if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
        var now = Date.now();
        view.lastIOSEnter = now;
        view.lastIOSEnterFallbackTimeout = setTimeout(function() {
          if (view.lastIOSEnter == now) {
            view.someProp("handleKeyDown", function(f) {
              return f(view, keyEvent(13, "Enter"));
            });
            view.lastIOSEnter = 0;
          }
        }, 200);
      } else if (view.someProp("handleKeyDown", function(f) {
        return f(view, event);
      }) || captureKeyDown(view, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "key");
      }
    };
    editHandlers.keyup = function(view, e) {
      if (e.keyCode == 16) {
        view.shiftKey = false;
      }
    };
    editHandlers.keypress = function(view, event) {
      if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || result.mac && event.metaKey) {
        return;
      }
      if (view.someProp("handleKeyPress", function(f) {
        return f(view, event);
      })) {
        event.preventDefault();
        return;
      }
      var sel = view.state.selection;
      if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
        var text = String.fromCharCode(event.charCode);
        if (!view.someProp("handleTextInput", function(f) {
          return f(view, sel.$from.pos, sel.$to.pos, text);
        })) {
          view.dispatch(view.state.tr.insertText(text).scrollIntoView());
        }
        event.preventDefault();
      }
    };
    selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";
    handlers.mousedown = function(view, event) {
      view.shiftKey = event.shiftKey;
      var flushed = forceDOMFlush(view);
      var now = Date.now(), type = "singleClick";
      if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
        if (view.lastClick.type == "singleClick") {
          type = "doubleClick";
        } else if (view.lastClick.type == "doubleClick") {
          type = "tripleClick";
        }
      }
      view.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
      var pos = view.posAtCoords(eventCoords(event));
      if (!pos) {
        return;
      }
      if (type == "singleClick") {
        if (view.mouseDown) {
          view.mouseDown.done();
        }
        view.mouseDown = new MouseDown(view, pos, event, flushed);
      } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "pointer");
      }
    };
    MouseDown = function MouseDown2(view, pos, event, flushed) {
      var this$1 = this;
      this.view = view;
      this.startDoc = view.state.doc;
      this.pos = pos;
      this.event = event;
      this.flushed = flushed;
      this.selectNode = event[selectNodeModifier];
      this.allowDefault = event.shiftKey;
      var targetNode, targetPos;
      if (pos.inside > -1) {
        targetNode = view.state.doc.nodeAt(pos.inside);
        targetPos = pos.inside;
      } else {
        var $pos = view.state.doc.resolve(pos.pos);
        targetNode = $pos.parent;
        targetPos = $pos.depth ? $pos.before() : 0;
      }
      this.mightDrag = null;
      var target = flushed ? null : event.target;
      var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
      this.target = targetDesc ? targetDesc.dom : null;
      if (targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || view.state.selection instanceof NodeSelection && targetPos == view.state.selection.from) {
        this.mightDrag = {
          node: targetNode,
          pos: targetPos,
          addAttr: this.target && !this.target.draggable,
          setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")
        };
      }
      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) {
          this.target.draggable = true;
        }
        if (this.mightDrag.setUneditable) {
          setTimeout(function() {
            if (this$1.view.mouseDown == this$1) {
              this$1.target.setAttribute("contentEditable", "false");
            }
          }, 20);
        }
        this.view.domObserver.start();
      }
      view.root.addEventListener("mouseup", this.up = this.up.bind(this));
      view.root.addEventListener("mousemove", this.move = this.move.bind(this));
      setSelectionOrigin(view, "pointer");
    };
    MouseDown.prototype.done = function done() {
      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);
      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) {
          this.target.removeAttribute("draggable");
        }
        if (this.mightDrag.setUneditable) {
          this.target.removeAttribute("contentEditable");
        }
        this.view.domObserver.start();
      }
      this.view.mouseDown = null;
    };
    MouseDown.prototype.up = function up(event) {
      this.done();
      if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
        return;
      }
      var pos = this.pos;
      if (this.view.state.doc != this.startDoc) {
        pos = this.view.posAtCoords(eventCoords(event));
      }
      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (this.flushed || result.safari && this.mightDrag && !this.mightDrag.node.isAtom || result.chrome && !(this.view.state.selection instanceof TextSelection) && (pos.pos == this.view.state.selection.from || pos.pos == this.view.state.selection.to)) {
        updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    };
    MouseDown.prototype.move = function move(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
        this.allowDefault = true;
      }
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0) {
        this.done();
      }
    };
    handlers.touchdown = function(view) {
      forceDOMFlush(view);
      setSelectionOrigin(view, "pointer");
    };
    handlers.contextmenu = function(view) {
      return forceDOMFlush(view);
    };
    timeoutComposition = result.android ? 5e3 : -1;
    editHandlers.compositionstart = editHandlers.compositionupdate = function(view) {
      if (!view.composing) {
        view.domObserver.flush();
        var state = view.state;
        var $pos = state.selection.$from;
        if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m) {
          return m.type.spec.inclusive === false;
        }))) {
          view.markCursor = view.state.storedMarks || $pos.marks();
          endComposition(view, true);
          view.markCursor = null;
        } else {
          endComposition(view);
          if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
            var sel = view.root.getSelection();
            for (var node2 = sel.focusNode, offset = sel.focusOffset; node2 && node2.nodeType == 1 && offset != 0; ) {
              var before = offset < 0 ? node2.lastChild : node2.childNodes[offset - 1];
              if (!before) {
                break;
              }
              if (before.nodeType == 3) {
                sel.collapse(before, before.nodeValue.length);
                break;
              } else {
                node2 = before;
                offset = -1;
              }
            }
          }
        }
        view.composing = true;
      }
      scheduleComposeEnd(view, timeoutComposition);
    };
    editHandlers.compositionend = function(view, event) {
      if (view.composing) {
        view.composing = false;
        view.compositionEndedAt = event.timeStamp;
        scheduleComposeEnd(view, 20);
      }
    };
    brokenClipboardAPI = result.ie && result.ie_version < 15 || result.ios && result.webkit_version < 604;
    handlers.copy = editHandlers.cut = function(view, e) {
      var sel = view.state.selection, cut = e.type == "cut";
      if (sel.empty) {
        return;
      }
      var data = brokenClipboardAPI ? null : e.clipboardData;
      var slice = sel.content();
      var ref = serializeForClipboard(view, slice);
      var dom = ref.dom;
      var text = ref.text;
      if (data) {
        e.preventDefault();
        data.clearData();
        data.setData("text/html", dom.innerHTML);
        data.setData("text/plain", text);
      } else {
        captureCopy(view, dom);
      }
      if (cut) {
        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
      }
    };
    editHandlers.paste = function(view, e) {
      var data = brokenClipboardAPI ? null : e.clipboardData;
      if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), e)) {
        e.preventDefault();
      } else {
        capturePaste(view, e);
      }
    };
    Dragging = function Dragging2(slice, move2) {
      this.slice = slice;
      this.move = move2;
    };
    dragCopyModifier = result.mac ? "altKey" : "ctrlKey";
    handlers.dragstart = function(view, e) {
      var mouseDown = view.mouseDown;
      if (mouseDown) {
        mouseDown.done();
      }
      if (!e.dataTransfer) {
        return;
      }
      var sel = view.state.selection;
      var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));
      if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
        ;
      else if (mouseDown && mouseDown.mightDrag) {
        view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
      } else if (e.target && e.target.nodeType == 1) {
        var desc = view.docView.nearestDesc(e.target, true);
        if (!desc || !desc.node.type.spec.draggable || desc == view.docView) {
          return;
        }
        view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
      }
      var slice = view.state.selection.content();
      var ref = serializeForClipboard(view, slice);
      var dom = ref.dom;
      var text = ref.text;
      e.dataTransfer.clearData();
      e.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
      e.dataTransfer.effectAllowed = "copyMove";
      if (!brokenClipboardAPI) {
        e.dataTransfer.setData("text/plain", text);
      }
      view.dragging = new Dragging(slice, !e[dragCopyModifier]);
    };
    handlers.dragend = function(view) {
      var dragging = view.dragging;
      window.setTimeout(function() {
        if (view.dragging == dragging) {
          view.dragging = null;
        }
      }, 50);
    };
    editHandlers.dragover = editHandlers.dragenter = function(_, e) {
      return e.preventDefault();
    };
    editHandlers.drop = function(view, e) {
      var dragging = view.dragging;
      view.dragging = null;
      if (!e.dataTransfer) {
        return;
      }
      var eventPos = view.posAtCoords(eventCoords(e));
      if (!eventPos) {
        return;
      }
      var $mouse = view.state.doc.resolve(eventPos.pos);
      if (!$mouse) {
        return;
      }
      var slice = dragging && dragging.slice || parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : e.dataTransfer.getData("text/html"), false, $mouse);
      var move2 = dragging && !e[dragCopyModifier];
      if (view.someProp("handleDrop", function(f) {
        return f(view, e, slice || Slice.empty, move2);
      })) {
        e.preventDefault();
        return;
      }
      if (!slice) {
        return;
      }
      e.preventDefault();
      var insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
      if (insertPos == null) {
        insertPos = $mouse.pos;
      }
      var tr = view.state.tr;
      if (move2) {
        tr.deleteSelection();
      }
      var pos = tr.mapping.map(insertPos);
      var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
      var beforeInsert = tr.doc;
      if (isNode) {
        tr.replaceRangeWith(pos, pos, slice.content.firstChild);
      } else {
        tr.replaceRange(pos, pos, slice);
      }
      if (tr.doc.eq(beforeInsert)) {
        return;
      }
      var $pos = tr.doc.resolve(pos);
      if (isNode && NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
        tr.setSelection(new NodeSelection($pos));
      } else {
        var end = tr.mapping.map(insertPos);
        tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
          return end = newTo;
        });
        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
      }
      view.focus();
      view.dispatch(tr.setMeta("uiEvent", "drop"));
    };
    handlers.focus = function(view) {
      if (!view.focused) {
        view.domObserver.stop();
        view.dom.classList.add("ProseMirror-focused");
        view.domObserver.start();
        view.focused = true;
        setTimeout(function() {
          if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection())) {
            selectionToDOM(view);
          }
        }, 20);
      }
    };
    handlers.blur = function(view) {
      if (view.focused) {
        view.domObserver.stop();
        view.dom.classList.remove("ProseMirror-focused");
        view.domObserver.start();
        view.domObserver.currentSelection.set({});
        view.focused = false;
      }
    };
    handlers.beforeinput = function(view, event) {
      if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
        var domChangeCount = view.domChangeCount;
        setTimeout(function() {
          if (view.domChangeCount != domChangeCount) {
            return;
          }
          view.dom.blur();
          view.focus();
          if (view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(8, "Backspace"));
          })) {
            return;
          }
          var ref = view.state.selection;
          var $cursor = ref.$cursor;
          if ($cursor && $cursor.pos > 0) {
            view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
          }
        }, 50);
      }
    };
    for (prop in editHandlers) {
      handlers[prop] = editHandlers[prop];
    }
    WidgetType = function WidgetType2(toDOM, spec) {
      this.spec = spec || noSpec;
      this.side = this.spec.side || 0;
      this.toDOM = toDOM;
    };
    WidgetType.prototype.map = function map(mapping, span, offset, oldOffset) {
      var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
      var pos = ref.pos;
      var deleted = ref.deleted;
      return deleted ? null : new Decoration(pos - offset, pos - offset, this);
    };
    WidgetType.prototype.valid = function valid() {
      return true;
    };
    WidgetType.prototype.eq = function eq2(other) {
      return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    };
    InlineType = function InlineType2(attrs, spec) {
      this.spec = spec || noSpec;
      this.attrs = attrs;
    };
    InlineType.prototype.map = function map2(mapping, span, offset, oldOffset) {
      var from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
      var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
      return from2 >= to ? null : new Decoration(from2, to, this);
    };
    InlineType.prototype.valid = function valid2(_, span) {
      return span.from < span.to;
    };
    InlineType.prototype.eq = function eq3(other) {
      return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    };
    InlineType.is = function is(span) {
      return span.type instanceof InlineType;
    };
    NodeType = function NodeType2(attrs, spec) {
      this.spec = spec || noSpec;
      this.attrs = attrs;
    };
    NodeType.prototype.map = function map3(mapping, span, offset, oldOffset) {
      var from2 = mapping.mapResult(span.from + oldOffset, 1);
      if (from2.deleted) {
        return null;
      }
      var to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from2.pos) {
        return null;
      }
      return new Decoration(from2.pos - offset, to.pos - offset, this);
    };
    NodeType.prototype.valid = function valid3(node2, span) {
      var ref = node2.content.findIndex(span.from);
      var index = ref.index;
      var offset = ref.offset;
      return offset == span.from && offset + node2.child(index).nodeSize == span.to;
    };
    NodeType.prototype.eq = function eq4(other) {
      return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    };
    Decoration = function Decoration2(from2, to, type) {
      this.from = from2;
      this.to = to;
      this.type = type;
    };
    prototypeAccessors$1 = { spec: { configurable: true }, inline: { configurable: true } };
    Decoration.prototype.copy = function copy(from2, to) {
      return new Decoration(from2, to, this.type);
    };
    Decoration.prototype.eq = function eq5(other, offset) {
      if (offset === void 0)
        offset = 0;
      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
    };
    Decoration.prototype.map = function map4(mapping, offset, oldOffset) {
      return this.type.map(mapping, this, offset, oldOffset);
    };
    Decoration.widget = function widget(pos, toDOM, spec) {
      return new Decoration(pos, pos, new WidgetType(toDOM, spec));
    };
    Decoration.inline = function inline(from2, to, attrs, spec) {
      return new Decoration(from2, to, new InlineType(attrs, spec));
    };
    Decoration.node = function node(from2, to, attrs, spec) {
      return new Decoration(from2, to, new NodeType(attrs, spec));
    };
    prototypeAccessors$1.spec.get = function() {
      return this.type.spec;
    };
    prototypeAccessors$1.inline.get = function() {
      return this.type instanceof InlineType;
    };
    Object.defineProperties(Decoration.prototype, prototypeAccessors$1);
    none = [];
    noSpec = {};
    DecorationSet = function DecorationSet2(local, children) {
      this.local = local && local.length ? local : none;
      this.children = children && children.length ? children : none;
    };
    DecorationSet.create = function create(doc, decorations) {
      return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;
    };
    DecorationSet.prototype.find = function find(start2, end, predicate) {
      var result2 = [];
      this.findInner(start2 == null ? 0 : start2, end == null ? 1e9 : end, result2, 0, predicate);
      return result2;
    };
    DecorationSet.prototype.findInner = function findInner(start2, end, result2, offset, predicate) {
      for (var i = 0; i < this.local.length; i++) {
        var span = this.local[i];
        if (span.from <= end && span.to >= start2 && (!predicate || predicate(span.spec))) {
          result2.push(span.copy(span.from + offset, span.to + offset));
        }
      }
      for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
        if (this.children[i$1] < end && this.children[i$1 + 1] > start2) {
          var childOff = this.children[i$1] + 1;
          this.children[i$1 + 2].findInner(start2 - childOff, end - childOff, result2, offset + childOff, predicate);
        }
      }
    };
    DecorationSet.prototype.map = function map5(mapping, doc, options) {
      if (this == empty || mapping.maps.length == 0) {
        return this;
      }
      return this.mapInner(mapping, doc, 0, 0, options || noSpec);
    };
    DecorationSet.prototype.mapInner = function mapInner(mapping, node2, offset, oldOffset, options) {
      var newLocal;
      for (var i = 0; i < this.local.length; i++) {
        var mapped = this.local[i].map(mapping, offset, oldOffset);
        if (mapped && mapped.type.valid(node2, mapped)) {
          (newLocal || (newLocal = [])).push(mapped);
        } else if (options.onRemove) {
          options.onRemove(this.local[i].spec);
        }
      }
      if (this.children.length) {
        return mapChildren(this.children, newLocal, mapping, node2, offset, oldOffset, options);
      } else {
        return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty;
      }
    };
    DecorationSet.prototype.add = function add(doc, decorations) {
      if (!decorations.length) {
        return this;
      }
      if (this == empty) {
        return DecorationSet.create(doc, decorations);
      }
      return this.addInner(doc, decorations, 0);
    };
    DecorationSet.prototype.addInner = function addInner(doc, decorations, offset) {
      var this$1 = this;
      var children, childIndex = 0;
      doc.forEach(function(childNode, childOffset) {
        var baseOffset = childOffset + offset, found;
        if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) {
          return;
        }
        if (!children) {
          children = this$1.children.slice();
        }
        while (childIndex < children.length && children[childIndex] < childOffset) {
          childIndex += 3;
        }
        if (children[childIndex] == childOffset) {
          children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);
        } else {
          children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
        }
        childIndex += 3;
      });
      var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
      for (var i = 0; i < local.length; i++) {
        if (!local[i].type.valid(doc, local[i])) {
          local.splice(i--, 1);
        }
      }
      return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    };
    DecorationSet.prototype.remove = function remove(decorations) {
      if (decorations.length == 0 || this == empty) {
        return this;
      }
      return this.removeInner(decorations, 0);
    };
    DecorationSet.prototype.removeInner = function removeInner(decorations, offset) {
      var children = this.children, local = this.local;
      for (var i = 0; i < children.length; i += 3) {
        var found = void 0, from2 = children[i] + offset, to = children[i + 1] + offset;
        for (var j = 0, span = void 0; j < decorations.length; j++) {
          if (span = decorations[j]) {
            if (span.from > from2 && span.to < to) {
              decorations[j] = null;
              (found || (found = [])).push(span);
            }
          }
        }
        if (!found) {
          continue;
        }
        if (children == this.children) {
          children = this.children.slice();
        }
        var removed = children[i + 2].removeInner(found, from2 + 1);
        if (removed != empty) {
          children[i + 2] = removed;
        } else {
          children.splice(i, 3);
          i -= 3;
        }
      }
      if (local.length) {
        for (var i$1 = 0, span$1 = void 0; i$1 < decorations.length; i$1++) {
          if (span$1 = decorations[i$1]) {
            for (var j$1 = 0; j$1 < local.length; j$1++) {
              if (local[j$1].eq(span$1, offset)) {
                if (local == this.local) {
                  local = this.local.slice();
                }
                local.splice(j$1--, 1);
              }
            }
          }
        }
      }
      if (children == this.children && local == this.local) {
        return this;
      }
      return local.length || children.length ? new DecorationSet(local, children) : empty;
    };
    DecorationSet.prototype.forChild = function forChild(offset, node2) {
      if (this == empty) {
        return this;
      }
      if (node2.isLeaf) {
        return DecorationSet.empty;
      }
      var child, local;
      for (var i = 0; i < this.children.length; i += 3) {
        if (this.children[i] >= offset) {
          if (this.children[i] == offset) {
            child = this.children[i + 2];
          }
          break;
        }
      }
      var start2 = offset + 1, end = start2 + node2.content.size;
      for (var i$1 = 0; i$1 < this.local.length; i$1++) {
        var dec = this.local[i$1];
        if (dec.from < end && dec.to > start2 && dec.type instanceof InlineType) {
          var from2 = Math.max(start2, dec.from) - start2, to = Math.min(end, dec.to) - start2;
          if (from2 < to) {
            (local || (local = [])).push(dec.copy(from2, to));
          }
        }
      }
      if (local) {
        var localSet = new DecorationSet(local.sort(byPos));
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }
      return child || empty;
    };
    DecorationSet.prototype.eq = function eq6(other) {
      if (this == other) {
        return true;
      }
      if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) {
        return false;
      }
      for (var i = 0; i < this.local.length; i++) {
        if (!this.local[i].eq(other.local[i])) {
          return false;
        }
      }
      for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
        if (this.children[i$1] != other.children[i$1] || this.children[i$1 + 1] != other.children[i$1 + 1] || !this.children[i$1 + 2].eq(other.children[i$1 + 2])) {
          return false;
        }
      }
      return true;
    };
    DecorationSet.prototype.locals = function locals(node2) {
      return removeOverlap(this.localsInner(node2));
    };
    DecorationSet.prototype.localsInner = function localsInner(node2) {
      if (this == empty) {
        return none;
      }
      if (node2.inlineContent || !this.local.some(InlineType.is)) {
        return this.local;
      }
      var result2 = [];
      for (var i = 0; i < this.local.length; i++) {
        if (!(this.local[i].type instanceof InlineType)) {
          result2.push(this.local[i]);
        }
      }
      return result2;
    };
    empty = new DecorationSet();
    DecorationSet.empty = empty;
    DecorationSet.removeOverlap = removeOverlap;
    DecorationGroup = function DecorationGroup2(members) {
      this.members = members;
    };
    DecorationGroup.prototype.forChild = function forChild2(offset, child) {
      if (child.isLeaf) {
        return DecorationSet.empty;
      }
      var found = [];
      for (var i = 0; i < this.members.length; i++) {
        var result2 = this.members[i].forChild(offset, child);
        if (result2 == empty) {
          continue;
        }
        if (result2 instanceof DecorationGroup) {
          found = found.concat(result2.members);
        } else {
          found.push(result2);
        }
      }
      return DecorationGroup.from(found);
    };
    DecorationGroup.prototype.eq = function eq7(other) {
      if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) {
        return false;
      }
      for (var i = 0; i < this.members.length; i++) {
        if (!this.members[i].eq(other.members[i])) {
          return false;
        }
      }
      return true;
    };
    DecorationGroup.prototype.locals = function locals2(node2) {
      var result2, sorted = true;
      for (var i = 0; i < this.members.length; i++) {
        var locals3 = this.members[i].localsInner(node2);
        if (!locals3.length) {
          continue;
        }
        if (!result2) {
          result2 = locals3;
        } else {
          if (sorted) {
            result2 = result2.slice();
            sorted = false;
          }
          for (var j = 0; j < locals3.length; j++) {
            result2.push(locals3[j]);
          }
        }
      }
      return result2 ? removeOverlap(sorted ? result2 : result2.sort(byPos)) : none;
    };
    DecorationGroup.from = function from(members) {
      switch (members.length) {
        case 0:
          return empty;
        case 1:
          return members[0];
        default:
          return new DecorationGroup(members);
      }
    };
    EditorView = function EditorView2(place, props) {
      this._props = props;
      this.state = props.state;
      this.dispatch = this.dispatch.bind(this);
      this._root = null;
      this.focused = false;
      this.trackWrites = null;
      this.dom = place && place.mount || document.createElement("div");
      if (place) {
        if (place.appendChild) {
          place.appendChild(this.dom);
        } else if (place.apply) {
          place(this.dom);
        } else if (place.mount) {
          this.mounted = true;
        }
      }
      this.editable = getEditable(this);
      this.markCursor = null;
      this.cursorWrapper = null;
      updateCursorWrapper(this);
      this.nodeViews = buildNodeViews(this);
      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
      this.lastSelectedViewDesc = null;
      this.dragging = null;
      initInput(this);
      this.pluginViews = [];
      this.updatePluginViews();
    };
    prototypeAccessors$2 = { props: { configurable: true }, root: { configurable: true } };
    prototypeAccessors$2.props.get = function() {
      if (this._props.state != this.state) {
        var prev = this._props;
        this._props = {};
        for (var name in prev) {
          this._props[name] = prev[name];
        }
        this._props.state = this.state;
      }
      return this._props;
    };
    EditorView.prototype.update = function update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents) {
        ensureListeners(this);
      }
      this._props = props;
      this.updateStateInner(props.state, true);
    };
    EditorView.prototype.setProps = function setProps(props) {
      var updated = {};
      for (var name in this._props) {
        updated[name] = this._props[name];
      }
      updated.state = this.state;
      for (var name$1 in props) {
        updated[name$1] = props[name$1];
      }
      this.update(updated);
    };
    EditorView.prototype.updateState = function updateState(state) {
      this.updateStateInner(state, this.state.plugins != state.plugins);
    };
    EditorView.prototype.updateStateInner = function updateStateInner(state, reconfigured) {
      var this$1 = this;
      var prev = this.state, redraw = false, updateSel = false;
      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }
      this.state = state;
      if (reconfigured) {
        var nodeViews = buildNodeViews(this);
        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
        ensureListeners(this);
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
      var scroll = reconfigured ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection)) {
        updateSel = true;
      }
      var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
      if (updateSel) {
        this.domObserver.stop();
        var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
        if (updateDoc) {
          var chromeKludge = result.chrome ? this.trackWrites = this.root.getSelection().focusNode : null;
          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco([]);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }
          if (chromeKludge && !this.trackWrites) {
            forceSelUpdate = true;
          }
        }
        if (forceSelUpdate || !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }
        this.domObserver.start();
      }
      this.updatePluginViews(prev);
      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        var startDOM = this.root.getSelection().focusNode;
        if (this.someProp("handleScrollToSelection", function(f) {
          return f(this$1);
        }))
          ;
        else if (state.selection instanceof NodeSelection) {
          scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM);
        } else {
          scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM);
        }
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    };
    EditorView.prototype.destroyPluginViews = function destroyPluginViews() {
      var view;
      while (view = this.pluginViews.pop()) {
        if (view.destroy) {
          view.destroy();
        }
      }
    };
    EditorView.prototype.updatePluginViews = function updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins) {
        this.destroyPluginViews();
        for (var i = 0; i < this.state.plugins.length; i++) {
          var plugin = this.state.plugins[i];
          if (plugin.spec.view) {
            this.pluginViews.push(plugin.spec.view(this));
          }
        }
      } else {
        for (var i$1 = 0; i$1 < this.pluginViews.length; i$1++) {
          var pluginView = this.pluginViews[i$1];
          if (pluginView.update) {
            pluginView.update(this, prevState);
          }
        }
      }
    };
    EditorView.prototype.someProp = function someProp(propName, f) {
      var prop = this._props && this._props[propName], value;
      if (prop != null && (value = f ? f(prop) : prop)) {
        return value;
      }
      var plugins = this.state.plugins;
      if (plugins) {
        for (var i = 0; i < plugins.length; i++) {
          var prop$1 = plugins[i].props[propName];
          if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) {
            return value;
          }
        }
      }
    };
    EditorView.prototype.hasFocus = function hasFocus() {
      return this.root.activeElement == this.dom;
    };
    EditorView.prototype.focus = function focus() {
      this.domObserver.stop();
      if (this.editable) {
        focusPreventScroll(this.dom);
      }
      selectionToDOM(this);
      this.domObserver.start();
    };
    prototypeAccessors$2.root.get = function() {
      var cached = this._root;
      if (cached == null) {
        for (var search = this.dom.parentNode; search; search = search.parentNode) {
          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
            if (!search.getSelection) {
              Object.getPrototypeOf(search).getSelection = function() {
                return document.getSelection();
              };
            }
            return this._root = search;
          }
        }
      }
      return cached || document;
    };
    EditorView.prototype.posAtCoords = function posAtCoords$1(coords) {
      return posAtCoords(this, coords);
    };
    EditorView.prototype.coordsAtPos = function coordsAtPos$1(pos, side) {
      if (side === void 0)
        side = 1;
      return coordsAtPos(this, pos, side);
    };
    EditorView.prototype.domAtPos = function domAtPos(pos, side) {
      if (side === void 0)
        side = 0;
      return this.docView.domFromPos(pos, side);
    };
    EditorView.prototype.nodeDOM = function nodeDOM(pos) {
      var desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    };
    EditorView.prototype.posAtDOM = function posAtDOM(node2, offset, bias) {
      if (bias === void 0)
        bias = -1;
      var pos = this.docView.posFromDOM(node2, offset, bias);
      if (pos == null) {
        throw new RangeError("DOM position not inside the editor");
      }
      return pos;
    };
    EditorView.prototype.endOfTextblock = function endOfTextblock$1(dir, state) {
      return endOfTextblock(this, state || this.state, dir);
    };
    EditorView.prototype.destroy = function destroy2() {
      if (!this.docView) {
        return;
      }
      destroyInput(this);
      this.destroyPluginViews();
      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      this.docView.destroy();
      this.docView = null;
    };
    EditorView.prototype.dispatchEvent = function dispatchEvent$1(event) {
      return dispatchEvent(this, event);
    };
    EditorView.prototype.dispatch = function dispatch(tr) {
      var dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction) {
        dispatchTransaction.call(this, tr);
      } else {
        this.updateState(this.state.apply(tr));
      }
    };
    Object.defineProperties(EditorView.prototype, prototypeAccessors$2);
  }
});

// ../node_modules/prosemirror-tables/dist/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  CellSelection: () => CellSelection,
  TableMap: () => TableMap,
  TableView: () => TableView,
  __clipCells: () => clipCells,
  __insertCells: () => insertCells,
  __pastedCells: () => pastedCells,
  addColSpan: () => addColSpan,
  addColumn: () => addColumn,
  addColumnAfter: () => addColumnAfter,
  addColumnBefore: () => addColumnBefore,
  addRow: () => addRow,
  addRowAfter: () => addRowAfter,
  addRowBefore: () => addRowBefore,
  cellAround: () => cellAround,
  colCount: () => colCount2,
  columnIsHeader: () => columnIsHeader,
  columnResizing: () => columnResizing,
  columnResizingPluginKey: () => key$1,
  deleteColumn: () => deleteColumn,
  deleteRow: () => deleteRow,
  deleteTable: () => deleteTable,
  findCell: () => findCell2,
  fixTables: () => fixTables,
  fixTablesKey: () => fixTablesKey,
  goToNextCell: () => goToNextCell,
  handlePaste: () => handlePaste,
  inSameTable: () => inSameTable,
  isInTable: () => isInTable,
  mergeCells: () => mergeCells,
  moveCellForward: () => moveCellForward,
  nextCell: () => nextCell2,
  pointsAtCell: () => pointsAtCell,
  removeColSpan: () => removeColSpan,
  removeColumn: () => removeColumn,
  removeRow: () => removeRow,
  rowIsHeader: () => rowIsHeader,
  selectedRect: () => selectedRect,
  selectionCell: () => selectionCell,
  setAttr: () => setAttr,
  setCellAttr: () => setCellAttr,
  splitCell: () => splitCell,
  splitCellWithType: () => splitCellWithType,
  tableEditing: () => tableEditing,
  tableEditingKey: () => key,
  tableNodeTypes: () => tableNodeTypes,
  tableNodes: () => tableNodes,
  toggleHeader: () => toggleHeader,
  toggleHeaderCell: () => toggleHeaderCell,
  toggleHeaderColumn: () => toggleHeaderColumn,
  toggleHeaderRow: () => toggleHeaderRow,
  updateColumnsOnResize: () => updateColumns
});
function computeMap(table) {
  if (table.type.spec.tableRole != "table") {
    throw new RangeError("Not a table node: " + table.type.name);
  }
  var width = findWidth(table), height = table.childCount;
  var map7 = [], mapPos = 0, problems = null, colWidths = [];
  for (var i = 0, e = width * height; i < e; i++) {
    map7[i] = 0;
  }
  for (var row = 0, pos = 0; row < height; row++) {
    var rowNode = table.child(row);
    pos++;
    for (var i$1 = 0; ; i$1++) {
      while (mapPos < map7.length && map7[mapPos] != 0) {
        mapPos++;
      }
      if (i$1 == rowNode.childCount) {
        break;
      }
      var cellNode = rowNode.child(i$1);
      var ref = cellNode.attrs;
      var colspan = ref.colspan;
      var rowspan = ref.rowspan;
      var colwidth = ref.colwidth;
      for (var h = 0; h < rowspan; h++) {
        if (h + row >= height) {
          (problems || (problems = [])).push({ type: "overlong_rowspan", pos, n: rowspan - h });
          break;
        }
        var start2 = mapPos + h * width;
        for (var w = 0; w < colspan; w++) {
          if (map7[start2 + w] == 0) {
            map7[start2 + w] = pos;
          } else {
            (problems || (problems = [])).push({ type: "collision", row, pos, n: colspan - w });
          }
          var colW = colwidth && colwidth[w];
          if (colW) {
            var widthIndex = (start2 + w) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    var expectedPos = (row + 1) * width, missing = 0;
    while (mapPos < expectedPos) {
      if (map7[mapPos++] == 0) {
        missing++;
      }
    }
    if (missing) {
      (problems || (problems = [])).push({ type: "missing", row, n: missing });
    }
    pos++;
  }
  var tableMap = new TableMap(width, height, map7, problems), badWidths = false;
  for (var i$2 = 0; !badWidths && i$2 < colWidths.length; i$2 += 2) {
    if (colWidths[i$2] != null && colWidths[i$2 + 1] < height) {
      badWidths = true;
    }
  }
  if (badWidths) {
    findBadColWidths(tableMap, colWidths, table);
  }
  return tableMap;
}
function findWidth(table) {
  var width = -1, hasRowSpan = false;
  for (var row = 0; row < table.childCount; row++) {
    var rowNode = table.child(row), rowWidth = 0;
    if (hasRowSpan) {
      for (var j = 0; j < row; j++) {
        var prevRow = table.child(j);
        for (var i = 0; i < prevRow.childCount; i++) {
          var cell = prevRow.child(i);
          if (j + cell.attrs.rowspan > row) {
            rowWidth += cell.attrs.colspan;
          }
        }
      }
    }
    for (var i$1 = 0; i$1 < rowNode.childCount; i$1++) {
      var cell$1 = rowNode.child(i$1);
      rowWidth += cell$1.attrs.colspan;
      if (cell$1.attrs.rowspan > 1) {
        hasRowSpan = true;
      }
    }
    if (width == -1) {
      width = rowWidth;
    } else if (width != rowWidth) {
      width = Math.max(width, rowWidth);
    }
  }
  return width;
}
function findBadColWidths(map7, colWidths, table) {
  if (!map7.problems) {
    map7.problems = [];
  }
  for (var i = 0, seen = {}; i < map7.map.length; i++) {
    var pos = map7.map[i];
    if (seen[pos]) {
      continue;
    }
    seen[pos] = true;
    var node2 = table.nodeAt(pos), updated = null;
    for (var j = 0; j < node2.attrs.colspan; j++) {
      var col = (i + j) % map7.width, colWidth = colWidths[col * 2];
      if (colWidth != null && (!node2.attrs.colwidth || node2.attrs.colwidth[j] != colWidth)) {
        (updated || (updated = freshColWidth(node2.attrs)))[j] = colWidth;
      }
    }
    if (updated) {
      map7.problems.unshift({ type: "colwidth mismatch", pos, colwidth: updated });
    }
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth) {
    return attrs.colwidth.slice();
  }
  var result2 = [];
  for (var i = 0; i < attrs.colspan; i++) {
    result2.push(0);
  }
  return result2;
}
function getCellAttrs(dom, extraAttrs) {
  var widthAttr = dom.getAttribute("data-colwidth");
  var widths = widthAttr && /^\d+(,\d+)*$/.test(widthAttr) ? widthAttr.split(",").map(function(s) {
    return Number(s);
  }) : null;
  var colspan = Number(dom.getAttribute("colspan") || 1);
  var result2 = {
    colspan,
    rowspan: Number(dom.getAttribute("rowspan") || 1),
    colwidth: widths && widths.length == colspan ? widths : null
  };
  for (var prop in extraAttrs) {
    var getter = extraAttrs[prop].getFromDOM;
    var value = getter && getter(dom);
    if (value != null) {
      result2[prop] = value;
    }
  }
  return result2;
}
function setCellAttrs(node2, extraAttrs) {
  var attrs = {};
  if (node2.attrs.colspan != 1) {
    attrs.colspan = node2.attrs.colspan;
  }
  if (node2.attrs.rowspan != 1) {
    attrs.rowspan = node2.attrs.rowspan;
  }
  if (node2.attrs.colwidth) {
    attrs["data-colwidth"] = node2.attrs.colwidth.join(",");
  }
  for (var prop in extraAttrs) {
    var setter = extraAttrs[prop].setDOMAttr;
    if (setter) {
      setter(node2.attrs[prop], attrs);
    }
  }
  return attrs;
}
function tableNodes(options) {
  var extraAttrs = options.cellAttributes || {};
  var cellAttrs = {
    colspan: { default: 1 },
    rowspan: { default: 1 },
    colwidth: { default: null }
  };
  for (var prop in extraAttrs) {
    cellAttrs[prop] = { default: extraAttrs[prop].default };
  }
  return {
    table: {
      content: "table_row+",
      tableRole: "table",
      isolating: true,
      group: options.tableGroup,
      parseDOM: [{ tag: "table" }],
      toDOM: function toDOM() {
        return ["table", ["tbody", 0]];
      }
    },
    table_row: {
      content: "(table_cell | table_header)*",
      tableRole: "row",
      parseDOM: [{ tag: "tr" }],
      toDOM: function toDOM() {
        return ["tr", 0];
      }
    },
    table_cell: {
      content: options.cellContent,
      attrs: cellAttrs,
      tableRole: "cell",
      isolating: true,
      parseDOM: [{ tag: "td", getAttrs: function(dom) {
        return getCellAttrs(dom, extraAttrs);
      } }],
      toDOM: function toDOM(node2) {
        return ["td", setCellAttrs(node2, extraAttrs), 0];
      }
    },
    table_header: {
      content: options.cellContent,
      attrs: cellAttrs,
      tableRole: "header_cell",
      isolating: true,
      parseDOM: [{ tag: "th", getAttrs: function(dom) {
        return getCellAttrs(dom, extraAttrs);
      } }],
      toDOM: function toDOM(node2) {
        return ["th", setCellAttrs(node2, extraAttrs), 0];
      }
    }
  };
}
function tableNodeTypes(schema) {
  var result2 = schema.cached.tableNodeTypes;
  if (!result2) {
    result2 = schema.cached.tableNodeTypes = {};
    for (var name in schema.nodes) {
      var type = schema.nodes[name], role = type.spec.tableRole;
      if (role) {
        result2[role] = type;
      }
    }
  }
  return result2;
}
function cellAround($pos) {
  for (var d = $pos.depth - 1; d > 0; d--) {
    if ($pos.node(d).type.spec.tableRole == "row") {
      return $pos.node(0).resolve($pos.before(d + 1));
    }
  }
  return null;
}
function cellWrapping($pos) {
  for (var d = $pos.depth; d > 0; d--) {
    var role = $pos.node(d).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") {
      return $pos.node(d);
    }
  }
  return null;
}
function isInTable(state) {
  var $head = state.selection.$head;
  for (var d = $head.depth; d > 0; d--) {
    if ($head.node(d).type.spec.tableRole == "row") {
      return true;
    }
  }
  return false;
}
function selectionCell(state) {
  var sel = state.selection;
  if (sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if (sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor;
  }
  return cellAround(sel.$head) || cellNear(sel.$head);
}
function cellNear($pos) {
  for (var after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
    var role = after.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") {
      return $pos.doc.resolve(pos);
    }
  }
  for (var before = $pos.nodeBefore, pos$1 = $pos.pos; before; before = before.lastChild, pos$1--) {
    var role$1 = before.type.spec.tableRole;
    if (role$1 == "cell" || role$1 == "header_cell") {
      return $pos.doc.resolve(pos$1 - before.nodeSize);
    }
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && $pos.nodeAfter;
}
function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
}
function inSameTable($a, $b) {
  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1);
}
function findCell2($pos) {
  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));
}
function colCount2($pos) {
  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));
}
function nextCell2($pos, axis, dir) {
  var start2 = $pos.start(-1), map7 = TableMap.get($pos.node(-1));
  var moved = map7.nextCell($pos.pos - start2, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(start2 + moved);
}
function setAttr(attrs, name, value) {
  var result2 = {};
  for (var prop in attrs) {
    result2[prop] = attrs[prop];
  }
  result2[name] = value;
  return result2;
}
function removeColSpan(attrs, pos, n) {
  if (n === void 0)
    n = 1;
  var result2 = setAttr(attrs, "colspan", attrs.colspan - n);
  if (result2.colwidth) {
    result2.colwidth = result2.colwidth.slice();
    result2.colwidth.splice(pos, n);
    if (!result2.colwidth.some(function(w) {
      return w > 0;
    })) {
      result2.colwidth = null;
    }
  }
  return result2;
}
function addColSpan(attrs, pos, n) {
  if (n === void 0)
    n = 1;
  var result2 = setAttr(attrs, "colspan", attrs.colspan + n);
  if (result2.colwidth) {
    result2.colwidth = result2.colwidth.slice();
    for (var i = 0; i < n; i++) {
      result2.colwidth.splice(pos, 0, 0);
    }
  }
  return result2;
}
function columnIsHeader(map7, table, col) {
  var headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (var row = 0; row < map7.height; row++) {
    if (table.nodeAt(map7.map[col + row * map7.width]).type != headerCell) {
      return false;
    }
  }
  return true;
}
function drawCellSelection(state) {
  if (!(state.selection instanceof CellSelection)) {
    return null;
  }
  var cells = [];
  state.selection.forEachCell(function(node2, pos) {
    cells.push(Decoration.node(pos, pos + node2.nodeSize, { class: "selectedCell" }));
  });
  return DecorationSet.create(state.doc, cells);
}
function isCellBoundarySelection(ref) {
  var $from = ref.$from;
  var $to = ref.$to;
  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) {
    return false;
  }
  var afterFrom = $from.pos, beforeTo = $to.pos, depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++) {
    if ($from.after(depth + 1) < $from.end(depth)) {
      break;
    }
  }
  for (var d = $to.depth; d >= 0; d--, beforeTo--) {
    if ($to.before(d + 1) > $to.start(d)) {
      break;
    }
  }
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells(ref) {
  var $from = ref.$from;
  var $to = ref.$to;
  var fromCellBoundaryNode;
  var toCellBoundaryNode;
  for (var i = $from.depth; i > 0; i--) {
    var node2 = $from.node(i);
    if (node2.type.spec.tableRole === "cell" || node2.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node2;
      break;
    }
  }
  for (var i$1 = $to.depth; i$1 > 0; i$1--) {
    var node$1 = $to.node(i$1);
    if (node$1.type.spec.tableRole === "cell" || node$1.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = node$1;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state, tr, allowTableNodeSelection) {
  var sel = (tr || state).selection, doc = (tr || state).doc, normalize, role;
  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize = CellSelection.create(doc, sel.from);
    } else if (role == "row") {
      var $cell = doc.resolve(sel.from + 1);
      normalize = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      var map7 = TableMap.get(sel.node), start2 = sel.from + 1;
      var lastCell = start2 + map7.map[map7.width * map7.height - 1];
      normalize = CellSelection.create(doc, start2 + 1, lastCell);
    }
  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
    normalize = TextSelection.create(doc, sel.from);
  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());
  }
  if (normalize) {
    (tr || (tr = state.tr)).setSelection(normalize);
  }
  return tr;
}
function pastedCells(slice) {
  if (!slice.size) {
    return null;
  }
  var content = slice.content;
  var openStart = slice.openStart;
  var openEnd = slice.openEnd;
  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.firstChild.type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content = content.firstChild.content;
  }
  var first = content.firstChild, role = first.type.spec.tableRole;
  var schema = first.type.schema, rows = [];
  if (role == "row") {
    for (var i = 0; i < content.childCount; i++) {
      var cells = content.child(i).content;
      var left = i ? 0 : Math.max(0, openStart - 1);
      var right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left || right) {
        cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, left, right)).content;
      }
      rows.push(cells);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice(content, openStart, openEnd)).content : content);
  } else {
    return null;
  }
  return ensureRectangular(schema, rows);
}
function ensureRectangular(schema, rows) {
  var widths = [];
  for (var i = 0; i < rows.length; i++) {
    var row = rows[i];
    for (var j = row.childCount - 1; j >= 0; j--) {
      var ref = row.child(j).attrs;
      var rowspan = ref.rowspan;
      var colspan = ref.colspan;
      for (var r = i; r < i + rowspan; r++) {
        widths[r] = (widths[r] || 0) + colspan;
      }
    }
  }
  var width = 0;
  for (var r$1 = 0; r$1 < widths.length; r$1++) {
    width = Math.max(width, widths[r$1]);
  }
  for (var r$2 = 0; r$2 < widths.length; r$2++) {
    if (r$2 >= rows.length) {
      rows.push(Fragment.empty);
    }
    if (widths[r$2] < width) {
      var empty2 = tableNodeTypes(schema).cell.createAndFill(), cells = [];
      for (var i$1 = widths[r$2]; i$1 < width; i$1++) {
        cells.push(empty2);
      }
      rows[r$2] = rows[r$2].append(Fragment.from(cells));
    }
  }
  return { height: rows.length, width, rows };
}
function fitSlice(nodeType, slice) {
  var node2 = nodeType.createAndFill();
  var tr = new Transform(node2).replace(0, node2.content.size, slice);
  return tr.doc;
}
function clipCells(ref, newWidth, newHeight) {
  var width = ref.width;
  var height = ref.height;
  var rows = ref.rows;
  if (width != newWidth) {
    var added = [], newRows = [];
    for (var row = 0; row < rows.length; row++) {
      var frag = rows[row], cells = [];
      for (var col = added[row] || 0, i = 0; col < newWidth; i++) {
        var cell = frag.child(i % frag.childCount);
        if (col + cell.attrs.colspan > newWidth) {
          cell = cell.type.create(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);
        }
        cells.push(cell);
        col += cell.attrs.colspan;
        for (var j = 1; j < cell.attrs.rowspan; j++) {
          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
        }
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    var newRows$1 = [];
    for (var row$1 = 0, i$1 = 0; row$1 < newHeight; row$1++, i$1++) {
      var cells$1 = [], source = rows[i$1 % height];
      for (var j$1 = 0; j$1 < source.childCount; j$1++) {
        var cell$1 = source.child(j$1);
        if (row$1 + cell$1.attrs.rowspan > newHeight) {
          cell$1 = cell$1.type.create(setAttr(cell$1.attrs, "rowspan", Math.max(1, newHeight - cell$1.attrs.rowspan)), cell$1.content);
        }
        cells$1.push(cell$1);
      }
      newRows$1.push(Fragment.from(cells$1));
    }
    rows = newRows$1;
    height = newHeight;
  }
  return { width, height, rows };
}
function growTable(tr, map7, table, start2, width, height, mapFrom) {
  var schema = tr.doc.type.schema, types = tableNodeTypes(schema), empty2, emptyHead;
  if (width > map7.width) {
    for (var row = 0, rowEnd = 0; row < map7.height; row++) {
      var rowNode = table.child(row);
      rowEnd += rowNode.nodeSize;
      var cells = [], add2 = void 0;
      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) {
        add2 = empty2 || (empty2 = types.cell.createAndFill());
      } else {
        add2 = emptyHead || (emptyHead = types.header_cell.createAndFill());
      }
      for (var i = map7.width; i < width; i++) {
        cells.push(add2);
      }
      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start2), cells);
    }
  }
  if (height > map7.height) {
    var cells$1 = [];
    for (var i$1 = 0, start$1 = (map7.height - 1) * map7.width; i$1 < Math.max(map7.width, width); i$1++) {
      var header = i$1 >= map7.width ? false : table.nodeAt(map7.map[start$1 + i$1]).type == types.header_cell;
      cells$1.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty2 || (empty2 = types.cell.createAndFill()));
    }
    var emptyRow = types.row.create(null, Fragment.from(cells$1)), rows = [];
    for (var i$2 = map7.height; i$2 < height; i$2++) {
      rows.push(emptyRow);
    }
    tr.insert(tr.mapping.slice(mapFrom).map(start2 + table.nodeSize - 2), rows);
  }
  return !!(empty2 || emptyHead);
}
function isolateHorizontal(tr, map7, table, start2, left, right, top, mapFrom) {
  if (top == 0 || top == map7.height) {
    return false;
  }
  var found = false;
  for (var col = left; col < right; col++) {
    var index = top * map7.width + col, pos = map7.map[index];
    if (map7.map[index - map7.width] == pos) {
      found = true;
      var cell = table.nodeAt(pos);
      var ref = map7.findCell(pos);
      var cellTop = ref.top;
      var cellLeft = ref.left;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start2), null, setAttr(cell.attrs, "rowspan", top - cellTop));
      tr.insert(tr.mapping.slice(mapFrom).map(map7.positionAt(top, cellLeft, table)), cell.type.createAndFill(setAttr(cell.attrs, "rowspan", cellTop + cell.attrs.rowspan - top)));
      col += cell.attrs.colspan - 1;
    }
  }
  return found;
}
function isolateVertical(tr, map7, table, start2, top, bottom, left, mapFrom) {
  if (left == 0 || left == map7.width) {
    return false;
  }
  var found = false;
  for (var row = top; row < bottom; row++) {
    var index = row * map7.width + left, pos = map7.map[index];
    if (map7.map[index - 1] == pos) {
      found = true;
      var cell = table.nodeAt(pos), cellLeft = map7.colCount(pos);
      var updatePos = tr.mapping.slice(mapFrom).map(pos + start2);
      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));
      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));
      row += cell.attrs.rowspan - 1;
    }
  }
  return found;
}
function insertCells(state, dispatch2, tableStart, rect, cells) {
  var table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc, map7 = TableMap.get(table);
  var top = rect.top;
  var left = rect.left;
  var right = left + cells.width, bottom = top + cells.height;
  var tr = state.tr, mapFrom = 0;
  function recomp() {
    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
    map7 = TableMap.get(table);
    mapFrom = tr.mapping.maps.length;
  }
  if (growTable(tr, map7, table, tableStart, right, bottom, mapFrom)) {
    recomp();
  }
  if (isolateHorizontal(tr, map7, table, tableStart, left, right, top, mapFrom)) {
    recomp();
  }
  if (isolateHorizontal(tr, map7, table, tableStart, left, right, bottom, mapFrom)) {
    recomp();
  }
  if (isolateVertical(tr, map7, table, tableStart, top, bottom, left, mapFrom)) {
    recomp();
  }
  if (isolateVertical(tr, map7, table, tableStart, top, bottom, right, mapFrom)) {
    recomp();
  }
  for (var row = top; row < bottom; row++) {
    var from2 = map7.positionAt(row, left, table), to = map7.positionAt(row, right, table);
    tr.replace(tr.mapping.slice(mapFrom).map(from2 + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new Slice(cells.rows[row - top], 0, 0));
  }
  recomp();
  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map7.positionAt(top, left, table)), tr.doc.resolve(tableStart + map7.positionAt(bottom - 1, right - 1, table))));
  dispatch2(tr);
}
function maybeSetSelection(state, dispatch2, selection) {
  if (selection.eq(state.selection)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.setSelection(selection).scrollIntoView());
  }
  return true;
}
function arrow(axis, dir) {
  return function(state, dispatch2, view) {
    var sel = state.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(state, dispatch2, Selection.near(sel.$headCell, dir));
    }
    if (axis != "horiz" && !sel.empty) {
      return false;
    }
    var end = atEndOfCell(view, axis, dir);
    if (end == null) {
      return false;
    }
    if (axis == "horiz") {
      return maybeSetSelection(state, dispatch2, Selection.near(state.doc.resolve(sel.head + dir), dir));
    } else {
      var $cell = state.doc.resolve(end), $next = nextCell2($cell, axis, dir), newSel;
      if ($next) {
        newSel = Selection.near($next, 1);
      } else if (dir < 0) {
        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
      } else {
        newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
      }
      return maybeSetSelection(state, dispatch2, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return function(state, dispatch2, view) {
    var sel = state.selection;
    if (!(sel instanceof CellSelection)) {
      var end = atEndOfCell(view, axis, dir);
      if (end == null) {
        return false;
      }
      sel = new CellSelection(state.doc.resolve(end));
    }
    var $head = nextCell2(sel.$headCell, axis, dir);
    if (!$head) {
      return false;
    }
    return maybeSetSelection(state, dispatch2, new CellSelection(sel.$anchorCell, $head));
  };
}
function deleteCellSelection(state, dispatch2) {
  var sel = state.selection;
  if (!(sel instanceof CellSelection)) {
    return false;
  }
  if (dispatch2) {
    var tr = state.tr, baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell(function(cell, pos) {
      if (!cell.content.eq(baseContent)) {
        tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new Slice(baseContent, 0, 0));
      }
    });
    if (tr.docChanged) {
      dispatch2(tr);
    }
  }
  return true;
}
function handleTripleClick2(view, pos) {
  var doc = view.state.doc, $cell = cellAround(doc.resolve(pos));
  if (!$cell) {
    return false;
  }
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _, slice) {
  if (!isInTable(view.state)) {
    return false;
  }
  var cells = pastedCells(slice), sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells) {
      cells = { width: 1, height: 1, rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))] };
    }
    var table = sel.$anchorCell.node(-1), start2 = sel.$anchorCell.start(-1);
    var rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start2, sel.$headCell.pos - start2);
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start2, rect, cells);
    return true;
  } else if (cells) {
    var $cell = selectionCell(view.state), start$1 = $cell.start(-1);
    insertCells(view.state, view.dispatch, start$1, TableMap.get($cell.node(-1)).findCell($cell.pos - start$1), cells);
    return true;
  } else {
    return false;
  }
}
function handleMouseDown(view, startEvent) {
  if (startEvent.ctrlKey || startEvent.metaKey) {
    return;
  }
  var startDOMCell = domInCell(view, startEvent.target), $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && cellUnderMouse(view, startEvent).pos != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    return;
  }
  function setCellSelection($anchor2, event) {
    var $head = cellUnderMouse(view, event);
    var starting = key.getState(view.state) == null;
    if (!$head || !inSameTable($anchor2, $head)) {
      if (starting) {
        $head = $anchor2;
      } else {
        return;
      }
    }
    var selection = new CellSelection($anchor2, $head);
    if (starting || !view.state.selection.eq(selection)) {
      var tr = view.state.tr.setSelection(selection);
      if (starting) {
        tr.setMeta(key, $anchor2.pos);
      }
      view.dispatch(tr);
    }
  }
  function stop2() {
    view.root.removeEventListener("mouseup", stop2);
    view.root.removeEventListener("dragstart", stop2);
    view.root.removeEventListener("mousemove", move2);
    if (key.getState(view.state) != null) {
      view.dispatch(view.state.tr.setMeta(key, -1));
    }
  }
  function move2(event) {
    var anchor = key.getState(view.state), $anchor2;
    if (anchor != null) {
      $anchor2 = view.state.doc.resolve(anchor);
    } else if (domInCell(view, event.target) != startDOMCell) {
      $anchor2 = cellUnderMouse(view, startEvent);
      if (!$anchor2) {
        return stop2();
      }
    }
    if ($anchor2) {
      setCellSelection($anchor2, event);
    }
  }
  view.root.addEventListener("mouseup", stop2);
  view.root.addEventListener("dragstart", stop2);
  view.root.addEventListener("mousemove", move2);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection)) {
    return null;
  }
  var ref = view.state.selection;
  var $head = ref.$head;
  for (var d = $head.depth - 1; d >= 0; d--) {
    var parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);
    if (index != (dir < 0 ? 0 : parent.childCount)) {
      return null;
    }
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      var cellPos = $head.before(d);
      var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode) {
    if (dom.nodeName == "TD" || dom.nodeName == "TH") {
      return dom;
    }
  }
}
function cellUnderMouse(view, event) {
  var mousePos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (!mousePos) {
    return null;
  }
  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
}
function changedDescendants(old, cur, offset, f) {
  var oldSize = old.childCount, curSize = cur.childCount;
  outer:
    for (var i = 0, j = 0; i < curSize; i++) {
      var child = cur.child(i);
      for (var scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {
        if (old.child(scan) == child) {
          j = scan + 1;
          offset += child.nodeSize;
          continue outer;
        }
      }
      f(child, offset);
      if (j < oldSize && old.child(j).sameMarkup(child)) {
        changedDescendants(old.child(j), child, offset + 1, f);
      } else {
        child.nodesBetween(0, child.content.size, f, offset + 1);
      }
      offset += child.nodeSize;
    }
}
function fixTables(state, oldState) {
  var tr, check = function(node2, pos) {
    if (node2.type.spec.tableRole == "table") {
      tr = fixTable(state, node2, pos, tr);
    }
  };
  if (!oldState) {
    state.doc.descendants(check);
  } else if (oldState.doc != state.doc) {
    changedDescendants(oldState.doc, state.doc, 0, check);
  }
  return tr;
}
function fixTable(state, table, tablePos, tr) {
  var map7 = TableMap.get(table);
  if (!map7.problems) {
    return tr;
  }
  if (!tr) {
    tr = state.tr;
  }
  var mustAdd = [];
  for (var i = 0; i < map7.height; i++) {
    mustAdd.push(0);
  }
  for (var i$1 = 0; i$1 < map7.problems.length; i$1++) {
    var prob = map7.problems[i$1];
    if (prob.type == "collision") {
      var cell = table.nodeAt(prob.pos);
      for (var j = 0; j < cell.attrs.rowspan; j++) {
        mustAdd[prob.row + j] += prob.n;
      }
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n));
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      var cell$1 = table.nodeAt(prob.pos);
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$1.attrs, "rowspan", cell$1.attrs.rowspan - prob.n));
    } else if (prob.type == "colwidth mismatch") {
      var cell$2 = table.nodeAt(prob.pos);
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$2.attrs, "colwidth", prob.colwidth));
    }
  }
  var first, last;
  for (var i$2 = 0; i$2 < mustAdd.length; i$2++) {
    if (mustAdd[i$2]) {
      if (first == null) {
        first = i$2;
      }
      last = i$2;
    }
  }
  for (var i$3 = 0, pos = tablePos + 1; i$3 < map7.height; i$3++) {
    var row = table.child(i$3);
    var end = pos + row.nodeSize;
    var add2 = mustAdd[i$3];
    if (add2 > 0) {
      var tableNodeType = "cell";
      if (row.firstChild) {
        tableNodeType = row.firstChild.type.spec.tableRole;
      }
      var nodes = [];
      for (var j$1 = 0; j$1 < add2; j$1++) {
        nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());
      }
      var side = (i$3 == 0 || first == i$3 - 1) && last == i$3 ? pos + 1 : end - 1;
      tr.insert(tr.mapping.map(side), nodes);
    }
    pos = end;
  }
  return tr.setMeta(fixTablesKey, { fixTables: true });
}
function selectedRect(state) {
  var sel = state.selection, $pos = selectionCell(state);
  var table = $pos.node(-1), tableStart = $pos.start(-1), map7 = TableMap.get(table);
  var rect;
  if (sel instanceof CellSelection) {
    rect = map7.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart);
  } else {
    rect = map7.findCell($pos.pos - tableStart);
  }
  rect.tableStart = tableStart;
  rect.map = map7;
  rect.table = table;
  return rect;
}
function addColumn(tr, ref, col) {
  var map7 = ref.map;
  var tableStart = ref.tableStart;
  var table = ref.table;
  var refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map7, table, col + refColumn)) {
    refColumn = col == 0 || col == map7.width ? null : 0;
  }
  for (var row = 0; row < map7.height; row++) {
    var index = row * map7.width + col;
    if (col > 0 && col < map7.width && map7.map[index - 1] == map7.map[index]) {
      var pos = map7.map[index], cell = table.nodeAt(pos);
      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map7.colCount(pos)));
      row += cell.attrs.rowspan - 1;
    } else {
      var type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map7.map[index + refColumn]).type;
      var pos$1 = map7.positionAt(row, col, table);
      tr.insert(tr.mapping.map(tableStart + pos$1), type.createAndFill());
    }
  }
  return tr;
}
function addColumnBefore(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state);
    dispatch2(addColumn(state.tr, rect, rect.left));
  }
  return true;
}
function addColumnAfter(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state);
    dispatch2(addColumn(state.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr, ref, col) {
  var map7 = ref.map;
  var table = ref.table;
  var tableStart = ref.tableStart;
  var mapStart = tr.mapping.maps.length;
  for (var row = 0; row < map7.height; ) {
    var index = row * map7.width + col, pos = map7.map[index], cell = table.nodeAt(pos);
    if (col > 0 && map7.map[index - 1] == pos || col < map7.width - 1 && map7.map[index + 1] == pos) {
      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(cell.attrs, col - map7.colCount(pos)));
    } else {
      var start2 = tr.mapping.slice(mapStart).map(tableStart + pos);
      tr.delete(start2, start2 + cell.nodeSize);
    }
    row += cell.attrs.rowspan;
  }
}
function deleteColumn(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state), tr = state.tr;
    if (rect.left == 0 && rect.right == rect.map.width) {
      return false;
    }
    for (var i = rect.right - 1; ; i--) {
      removeColumn(tr, rect, i);
      if (i == rect.left) {
        break;
      }
      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      rect.map = TableMap.get(rect.table);
    }
    dispatch2(tr);
  }
  return true;
}
function rowIsHeader(map7, table, row) {
  var headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (var col = 0; col < map7.width; col++) {
    if (table.nodeAt(map7.map[col + row * map7.width]).type != headerCell) {
      return false;
    }
  }
  return true;
}
function addRow(tr, ref, row) {
  var map7 = ref.map;
  var tableStart = ref.tableStart;
  var table = ref.table;
  var rowPos = tableStart;
  for (var i = 0; i < row; i++) {
    rowPos += table.child(i).nodeSize;
  }
  var cells = [], refRow = row > 0 ? -1 : 0;
  if (rowIsHeader(map7, table, row + refRow)) {
    refRow = row == 0 || row == map7.height ? null : 0;
  }
  for (var col = 0, index = map7.width * row; col < map7.width; col++, index++) {
    if (row > 0 && row < map7.height && map7.map[index] == map7.map[index - map7.width]) {
      var pos = map7.map[index], attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, "rowspan", attrs.rowspan + 1));
      col += attrs.colspan - 1;
    } else {
      var type = refRow == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map7.map[index + refRow * map7.width]).type;
      cells.push(type.createAndFill());
    }
  }
  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));
  return tr;
}
function addRowBefore(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state);
    dispatch2(addRow(state.tr, rect, rect.top));
  }
  return true;
}
function addRowAfter(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state);
    dispatch2(addRow(state.tr, rect, rect.bottom));
  }
  return true;
}
function removeRow(tr, ref, row) {
  var map7 = ref.map;
  var table = ref.table;
  var tableStart = ref.tableStart;
  var rowPos = 0;
  for (var i = 0; i < row; i++) {
    rowPos += table.child(i).nodeSize;
  }
  var nextRow = rowPos + table.child(row).nodeSize;
  var mapFrom = tr.mapping.maps.length;
  tr.delete(rowPos + tableStart, nextRow + tableStart);
  for (var col = 0, index = row * map7.width; col < map7.width; col++, index++) {
    var pos = map7.map[index];
    if (row > 0 && pos == map7.map[index - map7.width]) {
      var attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, "rowspan", attrs.rowspan - 1));
      col += attrs.colspan - 1;
    } else if (row < map7.width && pos == map7.map[index + map7.width]) {
      var cell = table.nodeAt(pos);
      var copy2 = cell.type.create(setAttr(cell.attrs, "rowspan", cell.attrs.rowspan - 1), cell.content);
      var newPos = map7.positionAt(row + 1, col, table);
      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy2);
      col += cell.attrs.colspan - 1;
    }
  }
}
function deleteRow(state, dispatch2) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch2) {
    var rect = selectedRect(state), tr = state.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height) {
      return false;
    }
    for (var i = rect.bottom - 1; ; i--) {
      removeRow(tr, rect, i);
      if (i == rect.top) {
        break;
      }
      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      rect.map = TableMap.get(rect.table);
    }
    dispatch2(tr);
  }
  return true;
}
function isEmpty(cell) {
  var c = cell.content;
  return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0;
}
function cellsOverlapRectangle(ref, rect) {
  var width = ref.width;
  var height = ref.height;
  var map7 = ref.map;
  var indexTop = rect.top * width + rect.left, indexLeft = indexTop;
  var indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
  for (var i = rect.top; i < rect.bottom; i++) {
    if (rect.left > 0 && map7[indexLeft] == map7[indexLeft - 1] || rect.right < width && map7[indexRight] == map7[indexRight + 1]) {
      return true;
    }
    indexLeft += width;
    indexRight += width;
  }
  for (var i$1 = rect.left; i$1 < rect.right; i$1++) {
    if (rect.top > 0 && map7[indexTop] == map7[indexTop - width] || rect.bottom < height && map7[indexBottom] == map7[indexBottom + width]) {
      return true;
    }
    indexTop++;
    indexBottom++;
  }
  return false;
}
function mergeCells(state, dispatch2) {
  var sel = state.selection;
  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) {
    return false;
  }
  var rect = selectedRect(state);
  var map7 = rect.map;
  if (cellsOverlapRectangle(map7, rect)) {
    return false;
  }
  if (dispatch2) {
    var tr = state.tr, seen = {}, content = Fragment.empty, mergedPos, mergedCell;
    for (var row = rect.top; row < rect.bottom; row++) {
      for (var col = rect.left; col < rect.right; col++) {
        var cellPos = map7.map[row * map7.width + col], cell = rect.table.nodeAt(cellPos);
        if (seen[cellPos]) {
          continue;
        }
        seen[cellPos] = true;
        if (mergedPos == null) {
          mergedPos = cellPos;
          mergedCell = cell;
        } else {
          if (!isEmpty(cell)) {
            content = content.append(cell.content);
          }
          var mapped = tr.mapping.map(cellPos + rect.tableStart);
          tr.delete(mapped, mapped + cell.nodeSize);
        }
      }
    }
    tr.setNodeMarkup(mergedPos + rect.tableStart, null, setAttr(addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan), "rowspan", rect.bottom - rect.top));
    if (content.size) {
      var end = mergedPos + 1 + mergedCell.content.size;
      var start2 = isEmpty(mergedCell) ? mergedPos + 1 : end;
      tr.replaceWith(start2 + rect.tableStart, end + rect.tableStart, content);
    }
    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));
    dispatch2(tr);
  }
  return true;
}
function splitCell(state, dispatch2) {
  var nodeTypes = tableNodeTypes(state.schema);
  return splitCellWithType(function(ref) {
    var node2 = ref.node;
    return nodeTypes[node2.type.spec.tableRole];
  })(state, dispatch2);
}
function splitCellWithType(getCellType) {
  return function(state, dispatch2) {
    var sel = state.selection;
    var cellNode, cellPos;
    if (!(sel instanceof CellSelection)) {
      cellNode = cellWrapping(sel.$from);
      if (!cellNode) {
        return false;
      }
      cellPos = cellAround(sel.$from).pos;
    } else {
      if (sel.$anchorCell.pos != sel.$headCell.pos) {
        return false;
      }
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
      return false;
    }
    if (dispatch2) {
      var baseAttrs = cellNode.attrs, attrs = [], colwidth = baseAttrs.colwidth;
      if (baseAttrs.rowspan > 1) {
        baseAttrs = setAttr(baseAttrs, "rowspan", 1);
      }
      if (baseAttrs.colspan > 1) {
        baseAttrs = setAttr(baseAttrs, "colspan", 1);
      }
      var rect = selectedRect(state), tr = state.tr;
      for (var i = 0; i < rect.right - rect.left; i++) {
        attrs.push(colwidth ? setAttr(baseAttrs, "colwidth", colwidth && colwidth[i] ? [colwidth[i]] : null) : baseAttrs);
      }
      var lastCell;
      for (var row = rect.top; row < rect.bottom; row++) {
        var pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row == rect.top) {
          pos += cellNode.nodeSize;
        }
        for (var col = rect.left, i$1 = 0; col < rect.right; col++, i$1++) {
          if (col == rect.left && row == rect.top) {
            continue;
          }
          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({ node: cellNode, row, col }).createAndFill(attrs[i$1]));
        }
      }
      tr.setNodeMarkup(cellPos, getCellType({ node: cellNode, row: rect.top, col: rect.left }), attrs[0]);
      if (sel instanceof CellSelection) {
        tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell && tr.doc.resolve(lastCell)));
      }
      dispatch2(tr);
    }
    return true;
  };
}
function setCellAttr(name, value) {
  return function(state, dispatch2) {
    if (!isInTable(state)) {
      return false;
    }
    var $cell = selectionCell(state);
    if ($cell.nodeAfter.attrs[name] === value) {
      return false;
    }
    if (dispatch2) {
      var tr = state.tr;
      if (state.selection instanceof CellSelection) {
        state.selection.forEachCell(function(node2, pos) {
          if (node2.attrs[name] !== value) {
            tr.setNodeMarkup(pos, null, setAttr(node2.attrs, name, value));
          }
        });
      } else {
        tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value));
      }
      dispatch2(tr);
    }
    return true;
  };
}
function deprecated_toggleHeader(type) {
  return function(state, dispatch2) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch2) {
      var types = tableNodeTypes(state.schema);
      var rect = selectedRect(state), tr = state.tr;
      var cells = rect.map.cellsInRect(type == "column" ? new Rect(rect.left, 0, rect.right, rect.map.height) : type == "row" ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect);
      var nodes = cells.map(function(pos) {
        return rect.table.nodeAt(pos);
      });
      for (var i = 0; i < cells.length; i++) {
        if (nodes[i].type == types.header_cell) {
          tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs);
        }
      }
      if (tr.steps.length == 0) {
        for (var i$1 = 0; i$1 < cells.length; i$1++) {
          tr.setNodeMarkup(rect.tableStart + cells[i$1], types.header_cell, nodes[i$1].attrs);
        }
      }
      dispatch2(tr);
    }
    return true;
  };
}
function isHeaderEnabledByType(type, rect, types) {
  var cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type == "row" ? rect.map.width : 1,
    bottom: type == "column" ? rect.map.height : 1
  });
  for (var i = 0; i < cellPositions.length; i++) {
    var cell = rect.table.nodeAt(cellPositions[i]);
    if (cell && cell.type !== types.header_cell) {
      return false;
    }
  }
  return true;
}
function toggleHeader(type, options) {
  options = options || { useDeprecatedLogic: false };
  if (options.useDeprecatedLogic) {
    return deprecated_toggleHeader(type);
  }
  return function(state, dispatch2) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch2) {
      var types = tableNodeTypes(state.schema);
      var rect = selectedRect(state), tr = state.tr;
      var isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
      var isHeaderColumnEnabled = isHeaderEnabledByType("column", rect, types);
      var isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
      var selectionStartsAt = isHeaderEnabled ? 1 : 0;
      var cellsRect = type == "column" ? new Rect(0, selectionStartsAt, 1, rect.map.height) : type == "row" ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;
      var newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
      rect.map.cellsInRect(cellsRect).forEach(function(relativeCellPos) {
        var cellPos = relativeCellPos + rect.tableStart;
        var cell = tr.doc.nodeAt(cellPos);
        if (cell) {
          tr.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });
      dispatch2(tr);
    }
    return true;
  };
}
function findNextCell($cell, dir) {
  if (dir < 0) {
    var before = $cell.nodeBefore;
    if (before) {
      return $cell.pos - before.nodeSize;
    }
    for (var row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
      var rowNode = $cell.node(-1).child(row);
      if (rowNode.childCount) {
        return rowEnd - 1 - rowNode.lastChild.nodeSize;
      }
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) {
      return $cell.pos + $cell.nodeAfter.nodeSize;
    }
    var table = $cell.node(-1);
    for (var row$1 = $cell.indexAfter(-1), rowStart = $cell.after(); row$1 < table.childCount; row$1++) {
      var rowNode$1 = table.child(row$1);
      if (rowNode$1.childCount) {
        return rowStart + 1;
      }
      rowStart += rowNode$1.nodeSize;
    }
  }
}
function goToNextCell(direction) {
  return function(state, dispatch2) {
    if (!isInTable(state)) {
      return false;
    }
    var cell = findNextCell(selectionCell(state), direction);
    if (cell == null) {
      return;
    }
    if (dispatch2) {
      var $cell = state.doc.resolve(cell);
      dispatch2(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());
    }
    return true;
  };
}
function deleteTable(state, dispatch2) {
  var $pos = state.selection.$anchor;
  for (var d = $pos.depth; d > 0; d--) {
    var node2 = $pos.node(d);
    if (node2.type.spec.tableRole == "table") {
      if (dispatch2) {
        dispatch2(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function updateColumns(node2, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
  var totalWidth = 0, fixedWidth = true;
  var nextDOM = colgroup.firstChild, row = node2.firstChild;
  for (var i = 0, col = 0; i < row.childCount; i++) {
    var ref = row.child(i).attrs;
    var colspan = ref.colspan;
    var colwidth = ref.colwidth;
    for (var j = 0; j < colspan; j++, col++) {
      var hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
      var cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth) {
        fixedWidth = false;
      }
      if (!nextDOM) {
        colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
      } else {
        if (nextDOM.style.width != cssWidth) {
          nextDOM.style.width = cssWidth;
        }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    var after = nextDOM.nextSibling;
    nextDOM.parentNode.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = totalWidth + "px";
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = totalWidth + "px";
  }
}
function columnResizing(ref) {
  if (ref === void 0)
    ref = {};
  var handleWidth = ref.handleWidth;
  if (handleWidth === void 0)
    handleWidth = 5;
  var cellMinWidth = ref.cellMinWidth;
  if (cellMinWidth === void 0)
    cellMinWidth = 25;
  var View = ref.View;
  if (View === void 0)
    View = TableView;
  var lastColumnResizable = ref.lastColumnResizable;
  if (lastColumnResizable === void 0)
    lastColumnResizable = true;
  var plugin = new Plugin({
    key: key$1,
    state: {
      init: function init(_, state) {
        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = function(node2, view) {
          return new View(node2, cellMinWidth, view);
        };
        return new ResizeState(-1, false);
      },
      apply: function apply3(tr, prev) {
        return prev.apply(tr);
      }
    },
    props: {
      attributes: function attributes(state) {
        var pluginState = key$1.getState(state);
        return pluginState.activeHandle > -1 ? { class: "resize-cursor" } : null;
      },
      handleDOMEvents: {
        mousemove: function mousemove(view, event) {
          handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable);
        },
        mouseleave: function mouseleave(view) {
          handleMouseLeave(view);
        },
        mousedown: function mousedown(view, event) {
          handleMouseDown$1(view, event, cellMinWidth);
        }
      },
      decorations: function decorations(state) {
        var pluginState = key$1.getState(state);
        if (pluginState.activeHandle > -1) {
          return handleDecorations(state, pluginState.activeHandle);
        }
      },
      nodeViews: {}
    }
  });
  return plugin;
}
function handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {
  var pluginState = key$1.getState(view.state);
  if (!pluginState.dragging) {
    var target = domCellAround(event.target), cell = -1;
    if (target) {
      var ref = target.getBoundingClientRect();
      var left = ref.left;
      var right = ref.right;
      if (event.clientX - left <= handleWidth) {
        cell = edgeCell(view, event, "left");
      } else if (right - event.clientX <= handleWidth) {
        cell = edgeCell(view, event, "right");
      }
    }
    if (cell != pluginState.activeHandle) {
      if (!lastColumnResizable && cell !== -1) {
        var $cell = view.state.doc.resolve(cell);
        var table = $cell.node(-1), map7 = TableMap.get(table), start2 = $cell.start(-1);
        var col = map7.colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
        if (col == map7.width - 1) {
          return;
        }
      }
      updateHandle(view, cell);
    }
  }
}
function handleMouseLeave(view) {
  var pluginState = key$1.getState(view.state);
  if (pluginState.activeHandle > -1 && !pluginState.dragging) {
    updateHandle(view, -1);
  }
}
function handleMouseDown$1(view, event, cellMinWidth) {
  var pluginState = key$1.getState(view.state);
  if (pluginState.activeHandle == -1 || pluginState.dragging) {
    return false;
  }
  var cell = view.state.doc.nodeAt(pluginState.activeHandle);
  var width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
  view.dispatch(view.state.tr.setMeta(key$1, { setDragging: { startX: event.clientX, startWidth: width } }));
  function finish(event2) {
    window.removeEventListener("mouseup", finish);
    window.removeEventListener("mousemove", move2);
    var pluginState2 = key$1.getState(view.state);
    if (pluginState2.dragging) {
      updateColumnWidth(view, pluginState2.activeHandle, draggedWidth(pluginState2.dragging, event2, cellMinWidth));
      view.dispatch(view.state.tr.setMeta(key$1, { setDragging: null }));
    }
  }
  function move2(event2) {
    if (!event2.which) {
      return finish(event2);
    }
    var pluginState2 = key$1.getState(view.state);
    var dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
    displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);
  }
  window.addEventListener("mouseup", finish);
  window.addEventListener("mousemove", move2);
  event.preventDefault();
  return true;
}
function currentColWidth(view, cellPos, ref) {
  var colspan = ref.colspan;
  var colwidth = ref.colwidth;
  var width = colwidth && colwidth[colwidth.length - 1];
  if (width) {
    return width;
  }
  var dom = view.domAtPos(cellPos);
  var node2 = dom.node.childNodes[dom.offset];
  var domWidth = node2.offsetWidth, parts = colspan;
  if (colwidth) {
    for (var i = 0; i < colspan; i++) {
      if (colwidth[i]) {
        domWidth -= colwidth[i];
        parts--;
      }
    }
  }
  return domWidth / parts;
}
function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH") {
    target = target.classList.contains("ProseMirror") ? null : target.parentNode;
  }
  return target;
}
function edgeCell(view, event, side) {
  var found = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (!found) {
    return -1;
  }
  var pos = found.pos;
  var $cell = cellAround(view.state.doc.resolve(pos));
  if (!$cell) {
    return -1;
  }
  if (side == "right") {
    return $cell.pos;
  }
  var map7 = TableMap.get($cell.node(-1)), start2 = $cell.start(-1);
  var index = map7.map.indexOf($cell.pos - start2);
  return index % map7.width == 0 ? -1 : start2 + map7.map[index - 1];
}
function draggedWidth(dragging, event, cellMinWidth) {
  var offset = event.clientX - dragging.startX;
  return Math.max(cellMinWidth, dragging.startWidth + offset);
}
function updateHandle(view, value) {
  view.dispatch(view.state.tr.setMeta(key$1, { setHandle: value }));
}
function updateColumnWidth(view, cell, width) {
  var $cell = view.state.doc.resolve(cell);
  var table = $cell.node(-1), map7 = TableMap.get(table), start2 = $cell.start(-1);
  var col = map7.colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  var tr = view.state.tr;
  for (var row = 0; row < map7.height; row++) {
    var mapIndex = row * map7.width + col;
    if (row && map7.map[mapIndex] == map7.map[mapIndex - map7.width]) {
      continue;
    }
    var pos = map7.map[mapIndex];
    var ref = table.nodeAt(pos);
    var attrs = ref.attrs;
    var index = attrs.colspan == 1 ? 0 : col - map7.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index] == width) {
      continue;
    }
    var colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index] = width;
    tr.setNodeMarkup(start2 + pos, null, setAttr(attrs, "colwidth", colwidth));
  }
  if (tr.docChanged) {
    view.dispatch(tr);
  }
}
function displayColumnWidth(view, cell, width, cellMinWidth) {
  var $cell = view.state.doc.resolve(cell);
  var table = $cell.node(-1), start2 = $cell.start(-1);
  var col = TableMap.get(table).colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  var dom = view.domAtPos($cell.start(-1)).node;
  while (dom.nodeName != "TABLE") {
    dom = dom.parentNode;
  }
  updateColumns(table, dom.firstChild, dom, cellMinWidth, col, width);
}
function zeroes(n) {
  var result2 = [];
  for (var i = 0; i < n; i++) {
    result2.push(0);
  }
  return result2;
}
function handleDecorations(state, cell) {
  var decorations = [];
  var $cell = state.doc.resolve(cell);
  var table = $cell.node(-1), map7 = TableMap.get(table), start2 = $cell.start(-1);
  var col = map7.colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan;
  for (var row = 0; row < map7.height; row++) {
    var index = col + row * map7.width - 1;
    if ((col == map7.width || map7.map[index] != map7.map[index + 1]) && (row == 0 || map7.map[index - 1] != map7.map[index - 1 - map7.width])) {
      var cellPos = map7.map[index];
      var pos = start2 + cellPos + table.nodeAt(cellPos).nodeSize - 1;
      var dom = document.createElement("div");
      dom.className = "column-resize-handle";
      decorations.push(Decoration.widget(pos, dom));
    }
  }
  return DecorationSet.create(state.doc, decorations);
}
function tableEditing(ref) {
  if (ref === void 0)
    ref = {};
  var allowTableNodeSelection = ref.allowTableNodeSelection;
  if (allowTableNodeSelection === void 0)
    allowTableNodeSelection = false;
  return new Plugin({
    key,
    state: {
      init: function init() {
        return null;
      },
      apply: function apply3(tr, cur) {
        var set2 = tr.getMeta(key);
        if (set2 != null) {
          return set2 == -1 ? null : set2;
        }
        if (cur == null || !tr.docChanged) {
          return cur;
        }
        var ref2 = tr.mapping.mapResult(cur);
        var deleted = ref2.deleted;
        var pos = ref2.pos;
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      handleDOMEvents: {
        mousedown: handleMouseDown
      },
      createSelectionBetween: function createSelectionBetween(view) {
        if (key.getState(view.state) != null) {
          return view.state.selection;
        }
      },
      handleTripleClick: handleTripleClick2,
      handleKeyDown,
      handlePaste
    },
    appendTransaction: function appendTransaction(_, oldState, state) {
      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);
    }
  });
}
var readFromCache, addToCache, cache, cache$1, cacheSize, cachePos, Rect, TableMap, key, CellSelection, CellBookmark, handleKeyDown, fixTablesKey, toggleHeaderRow, toggleHeaderColumn, toggleHeaderCell, TableView, key$1, ResizeState;
var init_index_es6 = __esm({
  "../node_modules/prosemirror-tables/dist/index.es.js"() {
    init_index_es3();
    init_index_es();
    init_index_es4();
    init_index_es5();
    init_index_es2();
    if (typeof WeakMap != "undefined") {
      cache = new WeakMap();
      readFromCache = function(key2) {
        return cache.get(key2);
      };
      addToCache = function(key2, value) {
        cache.set(key2, value);
        return value;
      };
    } else {
      cache$1 = [], cacheSize = 10, cachePos = 0;
      readFromCache = function(key2) {
        for (var i = 0; i < cache$1.length; i += 2) {
          if (cache$1[i] == key2) {
            return cache$1[i + 1];
          }
        }
      };
      addToCache = function(key2, value) {
        if (cachePos == cacheSize) {
          cachePos = 0;
        }
        cache$1[cachePos++] = key2;
        return cache$1[cachePos++] = value;
      };
    }
    Rect = function Rect2(left, top, right, bottom) {
      this.left = left;
      this.top = top;
      this.right = right;
      this.bottom = bottom;
    };
    TableMap = function TableMap2(width, height, map7, problems) {
      this.width = width;
      this.height = height;
      this.map = map7;
      this.problems = problems;
    };
    TableMap.prototype.findCell = function findCell(pos) {
      for (var i = 0; i < this.map.length; i++) {
        var curPos = this.map[i];
        if (curPos != pos) {
          continue;
        }
        var left = i % this.width, top = i / this.width | 0;
        var right = left + 1, bottom = top + 1;
        for (var j = 1; right < this.width && this.map[i + j] == curPos; j++) {
          right++;
        }
        for (var j$1 = 1; bottom < this.height && this.map[i + this.width * j$1] == curPos; j$1++) {
          bottom++;
        }
        return new Rect(left, top, right, bottom);
      }
      throw new RangeError("No cell with offset " + pos + " found");
    };
    TableMap.prototype.colCount = function colCount(pos) {
      for (var i = 0; i < this.map.length; i++) {
        if (this.map[i] == pos) {
          return i % this.width;
        }
      }
      throw new RangeError("No cell with offset " + pos + " found");
    };
    TableMap.prototype.nextCell = function nextCell(pos, axis, dir) {
      var ref = this.findCell(pos);
      var left = ref.left;
      var right = ref.right;
      var top = ref.top;
      var bottom = ref.bottom;
      if (axis == "horiz") {
        if (dir < 0 ? left == 0 : right == this.width) {
          return null;
        }
        return this.map[top * this.width + (dir < 0 ? left - 1 : right)];
      } else {
        if (dir < 0 ? top == 0 : bottom == this.height) {
          return null;
        }
        return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];
      }
    };
    TableMap.prototype.rectBetween = function rectBetween(a, b) {
      var ref = this.findCell(a);
      var leftA = ref.left;
      var rightA = ref.right;
      var topA = ref.top;
      var bottomA = ref.bottom;
      var ref$1 = this.findCell(b);
      var leftB = ref$1.left;
      var rightB = ref$1.right;
      var topB = ref$1.top;
      var bottomB = ref$1.bottom;
      return new Rect(Math.min(leftA, leftB), Math.min(topA, topB), Math.max(rightA, rightB), Math.max(bottomA, bottomB));
    };
    TableMap.prototype.cellsInRect = function cellsInRect(rect) {
      var result2 = [], seen = {};
      for (var row = rect.top; row < rect.bottom; row++) {
        for (var col = rect.left; col < rect.right; col++) {
          var index = row * this.width + col, pos = this.map[index];
          if (seen[pos]) {
            continue;
          }
          seen[pos] = true;
          if ((col != rect.left || !col || this.map[index - 1] != pos) && (row != rect.top || !row || this.map[index - this.width] != pos)) {
            result2.push(pos);
          }
        }
      }
      return result2;
    };
    TableMap.prototype.positionAt = function positionAt(row, col, table) {
      for (var i = 0, rowStart = 0; ; i++) {
        var rowEnd = rowStart + table.child(i).nodeSize;
        if (i == row) {
          var index = col + row * this.width, rowEndIndex = (row + 1) * this.width;
          while (index < rowEndIndex && this.map[index] < rowStart) {
            index++;
          }
          return index == rowEndIndex ? rowEnd - 1 : this.map[index];
        }
        rowStart = rowEnd;
      }
    };
    TableMap.get = function get(table) {
      return readFromCache(table) || addToCache(table, computeMap(table));
    };
    key = new PluginKey("selectingCells");
    CellSelection = function(Selection2) {
      function CellSelection2($anchorCell, $headCell) {
        if ($headCell === void 0)
          $headCell = $anchorCell;
        var table = $anchorCell.node(-1), map7 = TableMap.get(table), start2 = $anchorCell.start(-1);
        var rect = map7.rectBetween($anchorCell.pos - start2, $headCell.pos - start2);
        var doc = $anchorCell.node(0);
        var cells = map7.cellsInRect(rect).filter(function(p) {
          return p != $headCell.pos - start2;
        });
        cells.unshift($headCell.pos - start2);
        var ranges = cells.map(function(pos) {
          var cell = table.nodeAt(pos), from2 = pos + start2 + 1;
          return new SelectionRange(doc.resolve(from2), doc.resolve(from2 + cell.content.size));
        });
        Selection2.call(this, ranges[0].$from, ranges[0].$to, ranges);
        this.$anchorCell = $anchorCell;
        this.$headCell = $headCell;
      }
      if (Selection2)
        CellSelection2.__proto__ = Selection2;
      CellSelection2.prototype = Object.create(Selection2 && Selection2.prototype);
      CellSelection2.prototype.constructor = CellSelection2;
      CellSelection2.prototype.map = function map7(doc, mapping) {
        var $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));
        var $headCell = doc.resolve(mapping.map(this.$headCell.pos));
        if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
          var tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
          if (tableChanged && this.isRowSelection()) {
            return CellSelection2.rowSelection($anchorCell, $headCell);
          } else if (tableChanged && this.isColSelection()) {
            return CellSelection2.colSelection($anchorCell, $headCell);
          } else {
            return new CellSelection2($anchorCell, $headCell);
          }
        }
        return TextSelection.between($anchorCell, $headCell);
      };
      CellSelection2.prototype.content = function content() {
        var table = this.$anchorCell.node(-1), map7 = TableMap.get(table), start2 = this.$anchorCell.start(-1);
        var rect = map7.rectBetween(this.$anchorCell.pos - start2, this.$headCell.pos - start2);
        var seen = {}, rows = [];
        for (var row = rect.top; row < rect.bottom; row++) {
          var rowContent = [];
          for (var index = row * map7.width + rect.left, col = rect.left; col < rect.right; col++, index++) {
            var pos = map7.map[index];
            if (!seen[pos]) {
              seen[pos] = true;
              var cellRect = map7.findCell(pos), cell = table.nodeAt(pos);
              var extraLeft = rect.left - cellRect.left, extraRight = cellRect.right - rect.right;
              if (extraLeft > 0 || extraRight > 0) {
                var attrs = cell.attrs;
                if (extraLeft > 0) {
                  attrs = removeColSpan(attrs, 0, extraLeft);
                }
                if (extraRight > 0) {
                  attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);
                }
                if (cellRect.left < rect.left) {
                  cell = cell.type.createAndFill(attrs);
                } else {
                  cell = cell.type.create(attrs, cell.content);
                }
              }
              if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
                var attrs$1 = setAttr(cell.attrs, "rowspan", Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top));
                if (cellRect.top < rect.top) {
                  cell = cell.type.createAndFill(attrs$1);
                } else {
                  cell = cell.type.create(attrs$1, cell.content);
                }
              }
              rowContent.push(cell);
            }
          }
          rows.push(table.child(row).copy(Fragment.from(rowContent)));
        }
        var fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
        return new Slice(Fragment.from(fragment), 1, 1);
      };
      CellSelection2.prototype.replace = function replace(tr, content) {
        if (content === void 0)
          content = Slice.empty;
        var mapFrom = tr.steps.length, ranges = this.ranges;
        for (var i = 0; i < ranges.length; i++) {
          var ref = ranges[i];
          var $from = ref.$from;
          var $to = ref.$to;
          var mapping = tr.mapping.slice(mapFrom);
          tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
        }
        var sel = Selection2.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);
        if (sel) {
          tr.setSelection(sel);
        }
      };
      CellSelection2.prototype.replaceWith = function replaceWith(tr, node2) {
        this.replace(tr, new Slice(Fragment.from(node2), 0, 0));
      };
      CellSelection2.prototype.forEachCell = function forEachCell(f) {
        var table = this.$anchorCell.node(-1), map7 = TableMap.get(table), start2 = this.$anchorCell.start(-1);
        var cells = map7.cellsInRect(map7.rectBetween(this.$anchorCell.pos - start2, this.$headCell.pos - start2));
        for (var i = 0; i < cells.length; i++) {
          f(table.nodeAt(cells[i]), start2 + cells[i]);
        }
      };
      CellSelection2.prototype.isColSelection = function isColSelection() {
        var anchorTop = this.$anchorCell.index(-1), headTop = this.$headCell.index(-1);
        if (Math.min(anchorTop, headTop) > 0) {
          return false;
        }
        var anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan, headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;
        return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount;
      };
      CellSelection2.colSelection = function colSelection($anchorCell, $headCell) {
        if ($headCell === void 0)
          $headCell = $anchorCell;
        var map7 = TableMap.get($anchorCell.node(-1)), start2 = $anchorCell.start(-1);
        var anchorRect = map7.findCell($anchorCell.pos - start2), headRect = map7.findCell($headCell.pos - start2);
        var doc = $anchorCell.node(0);
        if (anchorRect.top <= headRect.top) {
          if (anchorRect.top > 0) {
            $anchorCell = doc.resolve(start2 + map7.map[anchorRect.left]);
          }
          if (headRect.bottom < map7.height) {
            $headCell = doc.resolve(start2 + map7.map[map7.width * (map7.height - 1) + headRect.right - 1]);
          }
        } else {
          if (headRect.top > 0) {
            $headCell = doc.resolve(start2 + map7.map[headRect.left]);
          }
          if (anchorRect.bottom < map7.height) {
            $anchorCell = doc.resolve(start2 + map7.map[map7.width * (map7.height - 1) + anchorRect.right - 1]);
          }
        }
        return new CellSelection2($anchorCell, $headCell);
      };
      CellSelection2.prototype.isRowSelection = function isRowSelection() {
        var map7 = TableMap.get(this.$anchorCell.node(-1)), start2 = this.$anchorCell.start(-1);
        var anchorLeft = map7.colCount(this.$anchorCell.pos - start2), headLeft = map7.colCount(this.$headCell.pos - start2);
        if (Math.min(anchorLeft, headLeft) > 0) {
          return false;
        }
        var anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan, headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
        return Math.max(anchorRight, headRight) == map7.width;
      };
      CellSelection2.prototype.eq = function eq8(other) {
        return other instanceof CellSelection2 && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
      };
      CellSelection2.rowSelection = function rowSelection($anchorCell, $headCell) {
        if ($headCell === void 0)
          $headCell = $anchorCell;
        var map7 = TableMap.get($anchorCell.node(-1)), start2 = $anchorCell.start(-1);
        var anchorRect = map7.findCell($anchorCell.pos - start2), headRect = map7.findCell($headCell.pos - start2);
        var doc = $anchorCell.node(0);
        if (anchorRect.left <= headRect.left) {
          if (anchorRect.left > 0) {
            $anchorCell = doc.resolve(start2 + map7.map[anchorRect.top * map7.width]);
          }
          if (headRect.right < map7.width) {
            $headCell = doc.resolve(start2 + map7.map[map7.width * (headRect.top + 1) - 1]);
          }
        } else {
          if (headRect.left > 0) {
            $headCell = doc.resolve(start2 + map7.map[headRect.top * map7.width]);
          }
          if (anchorRect.right < map7.width) {
            $anchorCell = doc.resolve(start2 + map7.map[map7.width * (anchorRect.top + 1) - 1]);
          }
        }
        return new CellSelection2($anchorCell, $headCell);
      };
      CellSelection2.prototype.toJSON = function toJSON() {
        return { type: "cell", anchor: this.$anchorCell.pos, head: this.$headCell.pos };
      };
      CellSelection2.fromJSON = function fromJSON(doc, json) {
        return new CellSelection2(doc.resolve(json.anchor), doc.resolve(json.head));
      };
      CellSelection2.create = function create2(doc, anchorCell, headCell) {
        if (headCell === void 0)
          headCell = anchorCell;
        return new CellSelection2(doc.resolve(anchorCell), doc.resolve(headCell));
      };
      CellSelection2.prototype.getBookmark = function getBookmark() {
        return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
      };
      return CellSelection2;
    }(Selection);
    CellSelection.prototype.visible = false;
    Selection.jsonID("cell", CellSelection);
    CellBookmark = function CellBookmark2(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    };
    CellBookmark.prototype.map = function map6(mapping) {
      return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
    };
    CellBookmark.prototype.resolve = function resolve(doc) {
      var $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);
      if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) {
        return new CellSelection($anchorCell, $headCell);
      } else {
        return Selection.near($headCell, 1);
      }
    };
    handleKeyDown = keydownHandler({
      "ArrowLeft": arrow("horiz", -1),
      "ArrowRight": arrow("horiz", 1),
      "ArrowUp": arrow("vert", -1),
      "ArrowDown": arrow("vert", 1),
      "Shift-ArrowLeft": shiftArrow("horiz", -1),
      "Shift-ArrowRight": shiftArrow("horiz", 1),
      "Shift-ArrowUp": shiftArrow("vert", -1),
      "Shift-ArrowDown": shiftArrow("vert", 1),
      "Backspace": deleteCellSelection,
      "Mod-Backspace": deleteCellSelection,
      "Delete": deleteCellSelection,
      "Mod-Delete": deleteCellSelection
    });
    fixTablesKey = new PluginKey("fix-tables");
    toggleHeaderRow = toggleHeader("row", { useDeprecatedLogic: true });
    toggleHeaderColumn = toggleHeader("column", { useDeprecatedLogic: true });
    toggleHeaderCell = toggleHeader("cell", { useDeprecatedLogic: true });
    TableView = function TableView2(node2, cellMinWidth) {
      this.node = node2;
      this.cellMinWidth = cellMinWidth;
      this.dom = document.createElement("div");
      this.dom.className = "tableWrapper";
      this.table = this.dom.appendChild(document.createElement("table"));
      this.colgroup = this.table.appendChild(document.createElement("colgroup"));
      updateColumns(node2, this.colgroup, this.table, cellMinWidth);
      this.contentDOM = this.table.appendChild(document.createElement("tbody"));
    };
    TableView.prototype.update = function update2(node2) {
      if (node2.type != this.node.type) {
        return false;
      }
      this.node = node2;
      updateColumns(node2, this.colgroup, this.table, this.cellMinWidth);
      return true;
    };
    TableView.prototype.ignoreMutation = function ignoreMutation2(record) {
      return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
    };
    key$1 = new PluginKey("tableColumnResizing");
    ResizeState = function ResizeState2(activeHandle, dragging) {
      this.activeHandle = activeHandle;
      this.dragging = dragging;
    };
    ResizeState.prototype.apply = function apply2(tr) {
      var state = this, action = tr.getMeta(key$1);
      if (action && action.setHandle != null) {
        return new ResizeState(action.setHandle, null);
      }
      if (action && action.setDragging !== void 0) {
        return new ResizeState(state.activeHandle, action.setDragging);
      }
      if (state.activeHandle > -1 && tr.docChanged) {
        var handle = tr.mapping.map(state.activeHandle, -1);
        if (!pointsAtCell(tr.doc.resolve(handle))) {
          handle = null;
        }
        state = new ResizeState(handle, state.dragging);
      }
      return state;
    };
  }
});

export {
  TableMap,
  tableNodes,
  tableNodeTypes,
  key,
  cellAround,
  isInTable,
  selectionCell,
  pointsAtCell,
  moveCellForward,
  inSameTable,
  findCell2 as findCell,
  colCount2 as colCount,
  nextCell2 as nextCell,
  setAttr,
  removeColSpan,
  addColSpan,
  columnIsHeader,
  CellSelection,
  pastedCells,
  clipCells,
  insertCells,
  handlePaste,
  fixTablesKey,
  fixTables,
  selectedRect,
  addColumn,
  addColumnBefore,
  addColumnAfter,
  removeColumn,
  deleteColumn,
  rowIsHeader,
  addRow,
  addRowBefore,
  addRowAfter,
  removeRow,
  deleteRow,
  mergeCells,
  splitCell,
  splitCellWithType,
  setCellAttr,
  toggleHeader,
  toggleHeaderRow,
  toggleHeaderColumn,
  toggleHeaderCell,
  goToNextCell,
  deleteTable,
  TableView,
  updateColumns,
  key$1,
  columnResizing,
  tableEditing,
  index_es_exports,
  init_index_es6 as init_index_es
};
//# sourceMappingURL=chunk-3GJDBDX5.js.map
