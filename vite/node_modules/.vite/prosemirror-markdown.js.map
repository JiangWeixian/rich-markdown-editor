{
  "version": 3,
  "sources": ["../../../node_modules/prosemirror-markdown/src/schema.js", "../../../node_modules/prosemirror-markdown/src/from_markdown.js", "../../../node_modules/prosemirror-markdown/src/to_markdown.js"],
  "sourcesContent": ["import {Schema} from \"prosemirror-model\"\n\n// ::Schema Document schema for the data model used by CommonMark.\nexport const schema = new Schema({\n  nodes: {\n    doc: {\n      content: \"block+\"\n    },\n\n    paragraph: {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{tag: \"p\"}],\n      toDOM() { return [\"p\", 0] }\n    },\n\n    blockquote: {\n      content: \"block+\",\n      group: \"block\",\n      parseDOM: [{tag: \"blockquote\"}],\n      toDOM() { return [\"blockquote\", 0] }\n    },\n\n    horizontal_rule: {\n      group: \"block\",\n      parseDOM: [{tag: \"hr\"}],\n      toDOM() { return [\"div\", [\"hr\"]] }\n    },\n\n    heading: {\n      attrs: {level: {default: 1}},\n      content: \"(text | image)*\",\n      group: \"block\",\n      defining: true,\n      parseDOM: [{tag: \"h1\", attrs: {level: 1}},\n                 {tag: \"h2\", attrs: {level: 2}},\n                 {tag: \"h3\", attrs: {level: 3}},\n                 {tag: \"h4\", attrs: {level: 4}},\n                 {tag: \"h5\", attrs: {level: 5}},\n                 {tag: \"h6\", attrs: {level: 6}}],\n      toDOM(node) { return [\"h\" + node.attrs.level, 0] }\n    },\n\n    code_block: {\n      content: \"text*\",\n      group: \"block\",\n      code: true,\n      defining: true,\n      marks: \"\",\n      attrs: {params: {default: \"\"}},\n      parseDOM: [{tag: \"pre\", preserveWhitespace: \"full\", getAttrs: node => (\n        {params: node.getAttribute(\"data-params\") || \"\"}\n      )}],\n      toDOM(node) { return [\"pre\", node.attrs.params ? {\"data-params\": node.attrs.params} : {}, [\"code\", 0]] }\n    },\n\n    ordered_list: {\n      content: \"list_item+\",\n      group: \"block\",\n      attrs: {order: {default: 1}, tight: {default: false}},\n      parseDOM: [{tag: \"ol\", getAttrs(dom) {\n        return {order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1,\n                tight: dom.hasAttribute(\"data-tight\")}\n      }}],\n      toDOM(node) {\n        return [\"ol\", {start: node.attrs.order == 1 ? null : node.attrs.order,\n                       \"data-tight\": node.attrs.tight ? \"true\" : null}, 0]\n      }\n    },\n\n    bullet_list: {\n      content: \"list_item+\",\n      group: \"block\",\n      attrs: {tight: {default: false}},\n      parseDOM: [{tag: \"ul\", getAttrs: dom => ({tight: dom.hasAttribute(\"data-tight\")})}],\n      toDOM(node) { return [\"ul\", {\"data-tight\": node.attrs.tight ? \"true\" : null}, 0] }\n    },\n\n    list_item: {\n      content: \"paragraph block*\",\n      defining: true,\n      parseDOM: [{tag: \"li\"}],\n      toDOM() { return [\"li\", 0] }\n    },\n\n    text: {\n      group: \"inline\"\n    },\n\n    image: {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: {default: null},\n        title: {default: null}\n      },\n      group: \"inline\",\n      draggable: true,\n      parseDOM: [{tag: \"img[src]\", getAttrs(dom) {\n        return {\n          src: dom.getAttribute(\"src\"),\n          title: dom.getAttribute(\"title\"),\n          alt: dom.getAttribute(\"alt\")\n        }\n      }}],\n      toDOM(node) { return [\"img\", node.attrs] }\n    },\n\n    hard_break: {\n      inline: true,\n      group: \"inline\",\n      selectable: false,\n      parseDOM: [{tag: \"br\"}],\n      toDOM() { return [\"br\"] }\n    }\n  },\n\n  marks: {\n    em: {\n      parseDOM: [{tag: \"i\"}, {tag: \"em\"},\n                 {style: \"font-style\", getAttrs: value => value == \"italic\" && null}],\n      toDOM() { return [\"em\"] }\n    },\n\n    strong: {\n      parseDOM: [{tag: \"b\"}, {tag: \"strong\"},\n                 {style: \"font-weight\", getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null}],\n      toDOM() { return [\"strong\"] }\n    },\n\n    link: {\n      attrs: {\n        href: {},\n        title: {default: null}\n      },\n      inclusive: false,\n      parseDOM: [{tag: \"a[href]\", getAttrs(dom) {\n        return {href: dom.getAttribute(\"href\"), title: dom.getAttribute(\"title\")}\n      }}],\n      toDOM(node) { return [\"a\", node.attrs] }\n    },\n\n    code: {\n      parseDOM: [{tag: \"code\"}],\n      toDOM() { return [\"code\"] }\n    }\n  }\n})\n", "import markdownit from \"markdown-it\"\nimport {schema} from \"./schema\"\nimport {Mark} from \"prosemirror-model\"\n\nfunction maybeMerge(a, b) {\n  if (a.isText && b.isText && Mark.sameSet(a.marks, b.marks))\n    return a.withText(a.text + b.text)\n}\n\n// Object used to track the context of a running parse.\nclass MarkdownParseState {\n  constructor(schema, tokenHandlers) {\n    this.schema = schema\n    this.stack = [{type: schema.topNodeType, content: []}]\n    this.marks = Mark.none\n    this.tokenHandlers = tokenHandlers\n  }\n\n  top() {\n    return this.stack[this.stack.length - 1]\n  }\n\n  push(elt) {\n    if (this.stack.length) this.top().content.push(elt)\n  }\n\n  // : (string)\n  // Adds the given text to the current position in the document,\n  // using the current marks as styling.\n  addText(text) {\n    if (!text) return\n    let nodes = this.top().content, last = nodes[nodes.length - 1]\n    let node = this.schema.text(text, this.marks), merged\n    if (last && (merged = maybeMerge(last, node))) nodes[nodes.length - 1] = merged\n    else nodes.push(node)\n  }\n\n  // : (Mark)\n  // Adds the given mark to the set of active marks.\n  openMark(mark) {\n    this.marks = mark.addToSet(this.marks)\n  }\n\n  // : (Mark)\n  // Removes the given mark from the set of active marks.\n  closeMark(mark) {\n    this.marks = mark.removeFromSet(this.marks)\n  }\n\n  parseTokens(toks) {\n    for (let i = 0; i < toks.length; i++) {\n      let tok = toks[i]\n      let handler = this.tokenHandlers[tok.type]\n      if (!handler)\n        throw new Error(\"Token type `\" + tok.type + \"` not supported by Markdown parser\")\n      handler(this, tok)\n    }\n  }\n\n  // : (NodeType, ?Object, ?[Node]) \u2192 ?Node\n  // Add a node at the current position.\n  addNode(type, attrs, content) {\n    let node = type.createAndFill(attrs, content, this.marks)\n    if (!node) return null\n    this.push(node)\n    return node\n  }\n\n  // : (NodeType, ?Object)\n  // Wrap subsequent content in a node of the given type.\n  openNode(type, attrs) {\n    this.stack.push({type: type, attrs: attrs, content: []})\n  }\n\n  // : () \u2192 ?Node\n  // Close and return the node that is currently on top of the stack.\n  closeNode() {\n    if (this.marks.length) this.marks = Mark.none\n    let info = this.stack.pop()\n    return this.addNode(info.type, info.attrs, info.content)\n  }\n}\n\nfunction attrs(spec, token) {\n  if (spec.getAttrs) return spec.getAttrs(token)\n  // For backwards compatibility when `attrs` is a Function\n  else if (spec.attrs instanceof Function) return spec.attrs(token)\n  else return spec.attrs\n}\n\n// Code content is represented as a single token with a `content`\n// property in Markdown-it.\nfunction noCloseToken(spec, type) {\n  return spec.noCloseToken || type == \"code_inline\" || type == \"code_block\" || type == \"fence\"\n}\n\nfunction withoutTrailingNewline(str) {\n  return str[str.length - 1] == \"\\n\" ? str.slice(0, str.length - 1) : str\n}\n\nfunction noOp() {}\n\nfunction tokenHandlers(schema, tokens) {\n  let handlers = Object.create(null)\n  for (let type in tokens) {\n    let spec = tokens[type]\n    if (spec.block) {\n      let nodeType = schema.nodeType(spec.block)\n      if (noCloseToken(spec, type)) {\n        handlers[type] = (state, tok) => {\n          state.openNode(nodeType, attrs(spec, tok))\n          state.addText(withoutTrailingNewline(tok.content))\n          state.closeNode()\n        }\n      } else {\n        handlers[type + \"_open\"] = (state, tok) => state.openNode(nodeType, attrs(spec, tok))\n        handlers[type + \"_close\"] = state => state.closeNode()\n      }\n    } else if (spec.node) {\n      let nodeType = schema.nodeType(spec.node)\n      handlers[type] = (state, tok) => state.addNode(nodeType, attrs(spec, tok))\n    } else if (spec.mark) {\n      let markType = schema.marks[spec.mark]\n      if (noCloseToken(spec, type)) {\n        handlers[type] = (state, tok) => {\n          state.openMark(markType.create(attrs(spec, tok)))\n          state.addText(withoutTrailingNewline(tok.content))\n          state.closeMark(markType)\n        }\n      } else {\n        handlers[type + \"_open\"] = (state, tok) => state.openMark(markType.create(attrs(spec, tok)))\n        handlers[type + \"_close\"] = state => state.closeMark(markType)\n      }\n    } else if (spec.ignore) {\n      if (noCloseToken(spec, type)) {\n        handlers[type] = noOp\n      } else {\n        handlers[type + '_open'] = noOp\n        handlers[type + '_close'] = noOp\n      }\n    } else {\n      throw new RangeError(\"Unrecognized parsing spec \" + JSON.stringify(spec))\n    }\n  }\n\n  handlers.text = (state, tok) => state.addText(tok.content)\n  handlers.inline = (state, tok) => state.parseTokens(tok.children)\n  handlers.softbreak = handlers.softbreak || (state => state.addText(\"\\n\"))\n\n  return handlers\n}\n\n// ::- A configuration of a Markdown parser. Such a parser uses\n// [markdown-it](https://github.com/markdown-it/markdown-it) to\n// tokenize a file, and then runs the custom rules it is given over\n// the tokens to create a ProseMirror document tree.\nexport class MarkdownParser {\n  // :: (Schema, MarkdownIt, Object)\n  // Create a parser with the given configuration. You can configure\n  // the markdown-it parser to parse the dialect you want, and provide\n  // a description of the ProseMirror entities those tokens map to in\n  // the `tokens` object, which maps token names to descriptions of\n  // what to do with them. Such a description is an object, and may\n  // have the following properties:\n  //\n  // **`node`**`: ?string`\n  //   : This token maps to a single node, whose type can be looked up\n  //     in the schema under the given name. Exactly one of `node`,\n  //     `block`, or `mark` must be set.\n  //\n  // **`block`**`: ?string`\n  //   : This token (unless `noCloseToken` is true) comes in `_open`\n  //     and `_close` variants (which are appended to the base token\n  //     name provides a the object property), and wraps a block of\n  //     content. The block should be wrapped in a node of the type\n  //     named to by the property's value. If the token does not have\n  //     `_open` or `_close`, use the `noCloseToken` option.\n  //\n  // **`mark`**`: ?string`\n  //   : This token (again, unless `noCloseToken` is true) also comes\n  //     in `_open` and `_close` variants, but should add a mark\n  //     (named by the value) to its content, rather than wrapping it\n  //     in a node.\n  //\n  // **`attrs`**`: ?Object`\n  //   : Attributes for the node or mark. When `getAttrs` is provided,\n  //     it takes precedence.\n  //\n  // **`getAttrs`**`: ?(MarkdownToken) \u2192 Object`\n  //   : A function used to compute the attributes for the node or mark\n  //     that takes a [markdown-it\n  //     token](https://markdown-it.github.io/markdown-it/#Token) and\n  //     returns an attribute object.\n  //\n  // **`noCloseToken`**`: ?boolean`\n  //   : Indicates that the [markdown-it\n  //     token](https://markdown-it.github.io/markdown-it/#Token) has\n  //     no `_open` or `_close` for the nodes. This defaults to `true`\n  //     for `code_inline`, `code_block` and `fence`.\n  //\n  // **`ignore`**`: ?bool`\n  //   : When true, ignore content for the matched token.\n  constructor(schema, tokenizer, tokens) {\n    // :: Object The value of the `tokens` object used to construct\n    // this parser. Can be useful to copy and modify to base other\n    // parsers on.\n    this.tokens = tokens\n    this.schema = schema\n    this.tokenizer = tokenizer\n    this.tokenHandlers = tokenHandlers(schema, tokens)\n  }\n\n  // :: (string) \u2192 Node\n  // Parse a string as [CommonMark](http://commonmark.org/) markup,\n  // and create a ProseMirror document as prescribed by this parser's\n  // rules.\n  parse(text) {\n    let state = new MarkdownParseState(this.schema, this.tokenHandlers), doc\n    state.parseTokens(this.tokenizer.parse(text, {}))\n    do { doc = state.closeNode() } while (state.stack.length)\n    return doc\n  }\n}\n\n// :: MarkdownParser\n// A parser parsing unextended [CommonMark](http://commonmark.org/),\n// without inline HTML, and producing a document in the basic schema.\nexport const defaultMarkdownParser = new MarkdownParser(schema, markdownit(\"commonmark\", {html: false}), {\n  blockquote: {block: \"blockquote\"},\n  paragraph: {block: \"paragraph\"},\n  list_item: {block: \"list_item\"},\n  bullet_list: {block: \"bullet_list\"},\n  ordered_list: {block: \"ordered_list\", getAttrs: tok => ({order: +tok.attrGet(\"start\") || 1})},\n  heading: {block: \"heading\", getAttrs: tok => ({level: +tok.tag.slice(1)})},\n  code_block: {block: \"code_block\", noCloseToken: true},\n  fence: {block: \"code_block\", getAttrs: tok => ({params: tok.info || \"\"}), noCloseToken: true},\n  hr: {node: \"horizontal_rule\"},\n  image: {node: \"image\", getAttrs: tok => ({\n    src: tok.attrGet(\"src\"),\n    title: tok.attrGet(\"title\") || null,\n    alt: tok.children[0] && tok.children[0].content || null\n  })},\n  hardbreak: {node: \"hard_break\"},\n\n  em: {mark: \"em\"},\n  strong: {mark: \"strong\"},\n  link: {mark: \"link\", getAttrs: tok => ({\n    href: tok.attrGet(\"href\"),\n    title: tok.attrGet(\"title\") || null\n  })},\n  code_inline: {mark: \"code\", noCloseToken: true}\n})\n", "// ::- A specification for serializing a ProseMirror document as\n// Markdown/CommonMark text.\nexport class MarkdownSerializer {\n  // :: (Object<(state: MarkdownSerializerState, node: Node, parent: Node, index: number)>, Object)\n  // Construct a serializer with the given configuration. The `nodes`\n  // object should map node names in a given schema to function that\n  // take a serializer state and such a node, and serialize the node.\n  //\n  // The `marks` object should hold objects with `open` and `close`\n  // properties, which hold the strings that should appear before and\n  // after a piece of text marked that way, either directly or as a\n  // function that takes a serializer state and a mark, and returns a\n  // string. `open` and `close` can also be functions, which will be\n  // called as\n  //\n  //     (state: MarkdownSerializerState, mark: Mark,\n  //      parent: Fragment, index: number) \u2192 string\n  //\n  // Where `parent` and `index` allow you to inspect the mark's\n  // context to see which nodes it applies to.\n  //\n  // Mark information objects can also have a `mixable` property\n  // which, when `true`, indicates that the order in which the mark's\n  // opening and closing syntax appears relative to other mixable\n  // marks can be varied. (For example, you can say `**a *b***` and\n  // `*a **b***`, but not `` `a *b*` ``.)\n  //\n  // To disable character escaping in a mark, you can give it an\n  // `escape` property of `false`. Such a mark has to have the highest\n  // precedence (must always be the innermost mark).\n  //\n  // The `expelEnclosingWhitespace` mark property causes the\n  // serializer to move enclosing whitespace from inside the marks to\n  // outside the marks. This is necessary for emphasis marks as\n  // CommonMark does not permit enclosing whitespace inside emphasis\n  // marks, see: http://spec.commonmark.org/0.26/#example-330\n  constructor(nodes, marks) {\n    // :: Object<(MarkdownSerializerState, Node)> The node serializer\n    // functions for this serializer.\n    this.nodes = nodes\n    // :: Object The mark serializer info.\n    this.marks = marks\n  }\n\n  // :: (Node, ?Object) \u2192 string\n  // Serialize the content of the given node to\n  // [CommonMark](http://commonmark.org/).\n  serialize(content, options) {\n    let state = new MarkdownSerializerState(this.nodes, this.marks, options)\n    state.renderContent(content)\n    return state.out\n  }\n}\n\n// :: MarkdownSerializer\n// A serializer for the [basic schema](#schema).\nexport const defaultMarkdownSerializer = new MarkdownSerializer({\n  blockquote(state, node) {\n    state.wrapBlock(\"> \", null, node, () => state.renderContent(node))\n  },\n  code_block(state, node) {\n    state.write(\"```\" + (node.attrs.params || \"\") + \"\\n\")\n    state.text(node.textContent, false)\n    state.ensureNewLine()\n    state.write(\"```\")\n    state.closeBlock(node)\n  },\n  heading(state, node) {\n    state.write(state.repeat(\"#\", node.attrs.level) + \" \")\n    state.renderInline(node)\n    state.closeBlock(node)\n  },\n  horizontal_rule(state, node) {\n    state.write(node.attrs.markup || \"---\")\n    state.closeBlock(node)\n  },\n  bullet_list(state, node) {\n    state.renderList(node, \"  \", () => (node.attrs.bullet || \"*\") + \" \")\n  },\n  ordered_list(state, node) {\n    let start = node.attrs.order || 1\n    let maxW = String(start + node.childCount - 1).length\n    let space = state.repeat(\" \", maxW + 2)\n    state.renderList(node, space, i => {\n      let nStr = String(start + i)\n      return state.repeat(\" \", maxW - nStr.length) + nStr + \". \"\n    })\n  },\n  list_item(state, node) {\n    state.renderContent(node)\n  },\n  paragraph(state, node) {\n    state.renderInline(node)\n    state.closeBlock(node)\n  },\n\n  image(state, node) {\n    state.write(\"![\" + state.esc(node.attrs.alt || \"\") + \"](\" + state.esc(node.attrs.src) +\n                (node.attrs.title ? \" \" + state.quote(node.attrs.title) : \"\") + \")\")\n  },\n  hard_break(state, node, parent, index) {\n    for (let i = index + 1; i < parent.childCount; i++)\n      if (parent.child(i).type != node.type) {\n        state.write(\"\\\\\\n\")\n        return\n      }\n  },\n  text(state, node) {\n    state.text(node.text)\n  }\n}, {\n  em: {open: \"*\", close: \"*\", mixable: true, expelEnclosingWhitespace: true},\n  strong: {open: \"**\", close: \"**\", mixable: true, expelEnclosingWhitespace: true},\n  link: {\n    open(_state, mark, parent, index) {\n      return isPlainURL(mark, parent, index, 1) ? \"<\" : \"[\"\n    },\n    close(state, mark, parent, index) {\n      return isPlainURL(mark, parent, index, -1) ? \">\"\n        : \"](\" + state.esc(mark.attrs.href) + (mark.attrs.title ? \" \" + state.quote(mark.attrs.title) : \"\") + \")\"\n    }\n  },\n  code: {open(_state, _mark, parent, index) { return backticksFor(parent.child(index), -1) },\n         close(_state, _mark, parent, index) { return backticksFor(parent.child(index - 1), 1) },\n         escape: false}\n})\n\nfunction backticksFor(node, side) {\n  let ticks = /`+/g, m, len = 0\n  if (node.isText) while (m = ticks.exec(node.text)) len = Math.max(len, m[0].length)\n  let result = len > 0 && side > 0 ? \" `\" : \"`\"\n  for (let i = 0; i < len; i++) result += \"`\"\n  if (len > 0 && side < 0) result += \" \"\n  return result\n}\n\nfunction isPlainURL(link, parent, index, side) {\n  if (link.attrs.title || !/^\\w+:/.test(link.attrs.href)) return false\n  let content = parent.child(index + (side < 0 ? -1 : 0))\n  if (!content.isText || content.text != link.attrs.href || content.marks[content.marks.length - 1] != link) return false\n  if (index == (side < 0 ? 1 : parent.childCount - 1)) return true\n  let next = parent.child(index + (side < 0 ? -2 : 1))\n  return !link.isInSet(next.marks)\n}\n\n// ::- This is an object used to track state and expose\n// methods related to markdown serialization. Instances are passed to\n// node and mark serialization methods (see `toMarkdown`).\nexport class MarkdownSerializerState {\n  constructor(nodes, marks, options) {\n    this.nodes = nodes\n    this.marks = marks\n    this.delim = this.out = \"\"\n    this.closed = false\n    this.inTightList = false\n    // :: Object\n    // The options passed to the serializer.\n    //   tightLists:: ?bool\n    //   Whether to render lists in a tight style. This can be overridden\n    //   on a node level by specifying a tight attribute on the node.\n    //   Defaults to false.\n    this.options = options || {}\n    if (typeof this.options.tightLists == \"undefined\")\n      this.options.tightLists = false\n  }\n\n  flushClose(size) {\n    if (this.closed) {\n      if (!this.atBlank()) this.out += \"\\n\"\n      if (size == null) size = 2\n      if (size > 1) {\n        let delimMin = this.delim\n        let trim = /\\s+$/.exec(delimMin)\n        if (trim) delimMin = delimMin.slice(0, delimMin.length - trim[0].length)\n        for (let i = 1; i < size; i++)\n          this.out += delimMin + \"\\n\"\n      }\n      this.closed = false\n    }\n  }\n\n  // :: (string, ?string, Node, ())\n  // Render a block, prefixing each line with `delim`, and the first\n  // line in `firstDelim`. `node` should be the node that is closed at\n  // the end of the block, and `f` is a function that renders the\n  // content of the block.\n  wrapBlock(delim, firstDelim, node, f) {\n    let old = this.delim\n    this.write(firstDelim || delim)\n    this.delim += delim\n    f()\n    this.delim = old\n    this.closeBlock(node)\n  }\n\n  atBlank() {\n    return /(^|\\n)$/.test(this.out)\n  }\n\n  // :: ()\n  // Ensure the current content ends with a newline.\n  ensureNewLine() {\n    if (!this.atBlank()) this.out += \"\\n\"\n  }\n\n  // :: (?string)\n  // Prepare the state for writing output (closing closed paragraphs,\n  // adding delimiters, and so on), and then optionally add content\n  // (unescaped) to the output.\n  write(content) {\n    this.flushClose()\n    if (this.delim && this.atBlank())\n      this.out += this.delim\n    if (content) this.out += content\n  }\n\n  // :: (Node)\n  // Close the block for the given node.\n  closeBlock(node) {\n    this.closed = node\n  }\n\n  // :: (string, ?bool)\n  // Add the given text to the document. When escape is not `false`,\n  // it will be escaped.\n  text(text, escape) {\n    let lines = text.split(\"\\n\")\n    for (let i = 0; i < lines.length; i++) {\n      var startOfLine = this.atBlank() || this.closed\n      this.write()\n      this.out += escape !== false ? this.esc(lines[i], startOfLine) : lines[i]\n      if (i != lines.length - 1) this.out += \"\\n\"\n    }\n  }\n\n  // :: (Node)\n  // Render the given node as a block.\n  render(node, parent, index) {\n    if (typeof parent == \"number\") throw new Error(\"!\")\n    this.nodes[node.type.name](this, node, parent, index)\n  }\n\n  // :: (Node)\n  // Render the contents of `parent` as block nodes.\n  renderContent(parent) {\n    parent.forEach((node, _, i) => this.render(node, parent, i))\n  }\n\n  // :: (Node)\n  // Render the contents of `parent` as inline content.\n  renderInline(parent) {\n    let active = [], trailing = \"\"\n    let progress = (node, _, index) => {\n      let marks = node ? node.marks : []\n\n      // Remove marks from `hard_break` that are the last node inside\n      // that mark to prevent parser edge cases with new lines just\n      // before closing marks.\n      // (FIXME it'd be nice if we had a schema-agnostic way to\n      // identify nodes that serialize as hard breaks)\n      if (node && node.type.name === \"hard_break\")\n        marks = marks.filter(m => {\n          if (index + 1 == parent.childCount) return false\n          let next = parent.child(index + 1)\n          return m.isInSet(next.marks) && (!next.isText || /\\S/.test(next.text))\n        })\n\n      let leading = trailing\n      trailing = \"\"\n      // If whitespace has to be expelled from the node, adjust\n      // leading and trailing accordingly.\n      if (node && node.isText && marks.some(mark => {\n        let info = this.marks[mark.type.name]\n        return info && info.expelEnclosingWhitespace\n      })) {\n        let [_, lead, inner, trail] = /^(\\s*)(.*?)(\\s*)$/m.exec(node.text)\n        leading += lead\n        trailing = trail\n        if (lead || trail) {\n          node = inner ? node.withText(inner) : null\n          if (!node) marks = active\n        }\n      }\n\n      let inner = marks.length && marks[marks.length - 1], noEsc = inner && this.marks[inner.type.name].escape === false\n      let len = marks.length - (noEsc ? 1 : 0)\n\n      // Try to reorder 'mixable' marks, such as em and strong, which\n      // in Markdown may be opened and closed in different order, so\n      // that order of the marks for the token matches the order in\n      // active.\n      outer: for (let i = 0; i < len; i++) {\n        let mark = marks[i]\n        if (!this.marks[mark.type.name].mixable) break\n        for (let j = 0; j < active.length; j++) {\n          let other = active[j]\n          if (!this.marks[other.type.name].mixable) break\n          if (mark.eq(other)) {\n            if (i > j)\n              marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i)).concat(marks.slice(i + 1, len))\n            else if (j > i)\n              marks = marks.slice(0, i).concat(marks.slice(i + 1, j)).concat(mark).concat(marks.slice(j, len))\n            continue outer\n          }\n        }\n      }\n\n      // Find the prefix of the mark set that didn't change\n      let keep = 0\n      while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) ++keep\n\n      // Close the marks that need to be closed\n      while (keep < active.length)\n        this.text(this.markString(active.pop(), false, parent, index), false)\n\n      // Output any previously expelled trailing whitespace outside the marks\n      if (leading) this.text(leading)\n\n      // Open the marks that need to be opened\n      if (node) {\n        while (active.length < len) {\n          let add = marks[active.length]\n          active.push(add)\n          this.text(this.markString(add, true, parent, index), false)\n        }\n\n        // Render the node. Special case code marks, since their content\n        // may not be escaped.\n        if (noEsc && node.isText)\n          this.text(this.markString(inner, true, parent, index) + node.text +\n                    this.markString(inner, false, parent, index + 1), false)\n        else\n          this.render(node, parent, index)\n      }\n    }\n    parent.forEach(progress)\n    progress(null, null, parent.childCount)\n  }\n\n  // :: (Node, string, (number) \u2192 string)\n  // Render a node's content as a list. `delim` should be the extra\n  // indentation added to all lines except the first in an item,\n  // `firstDelim` is a function going from an item index to a\n  // delimiter for the first line of the item.\n  renderList(node, delim, firstDelim) {\n    if (this.closed && this.closed.type == node.type)\n      this.flushClose(3)\n    else if (this.inTightList)\n      this.flushClose(1)\n\n    let isTight = typeof node.attrs.tight != \"undefined\" ? node.attrs.tight : this.options.tightLists\n    let prevTight = this.inTightList\n    this.inTightList = isTight\n    node.forEach((child, _, i) => {\n      if (i && isTight) this.flushClose(1)\n      this.wrapBlock(delim, firstDelim(i), node, () => this.render(child, node, i))\n    })\n    this.inTightList = prevTight\n  }\n\n  // :: (string, ?bool) \u2192 string\n  // Escape the given string so that it can safely appear in Markdown\n  // content. If `startOfLine` is true, also escape characters that\n  // has special meaning only at the start of the line.\n  esc(str, startOfLine) {\n    str = str.replace(/[`*\\\\~\\[\\]]/g, \"\\\\$&\")\n    if (startOfLine) str = str.replace(/^[:#\\-*+]/, \"\\\\$&\").replace(/^(\\d+)\\./, \"$1\\\\.\")\n    return str\n  }\n\n  quote(str) {\n    var wrap = str.indexOf('\"') == -1 ? '\"\"' : str.indexOf(\"'\") == -1 ? \"''\" : \"()\"\n    return wrap[0] + str + wrap[1]\n  }\n\n  // :: (string, number) \u2192 string\n  // Repeat the given string `n` times.\n  repeat(str, n) {\n    let out = \"\"\n    for (let i = 0; i < n; i++) out += str\n    return out\n  }\n\n  // : (Mark, bool, string?) \u2192 string\n  // Get the markdown string for a given opening or closing mark.\n  markString(mark, open, parent, index) {\n    let info = this.marks[mark.type.name]\n    let value = open ? info.open : info.close\n    return typeof value == \"string\" ? value : value(this, mark, parent, index)\n  }\n\n  // :: (string) \u2192 { leading: ?string, trailing: ?string }\n  // Get leading and trailing whitespace from a string. Values of\n  // leading or trailing property of the return object will be undefined\n  // if there is no match.\n  getEnclosingWhitespace(text) {\n    return {\n      leading: (text.match(/^(\\s+)/) || [])[0],\n      trailing: (text.match(/(\\s+)$/) || [])[0]\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
