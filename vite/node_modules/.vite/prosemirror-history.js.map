{
  "version": 3,
  "sources": ["../../../node_modules/rope-sequence/dist/index.es.js", "../../../node_modules/prosemirror-history/src/history.js"],
  "sourcesContent": ["var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) \u2192 RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) \u2192 RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) \u2192 T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) \u2192 ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) \u2192 U, ?number, ?number) \u2192 [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) \u2192 RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nvar ropeSequence = RopeSequence;\n\nexport default ropeSequence;\n", "import RopeSequence from \"rope-sequence\"\nimport {Mapping} from \"prosemirror-transform\"\nimport {Plugin, PluginKey} from \"prosemirror-state\"\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' \u2014 a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n\n// Used to schedule history compression\nconst max_empty_items = 500\n\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items\n    this.eventCount = eventCount\n  }\n\n  // : (EditorState, bool) \u2192 ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0) return null\n\n    let end = this.items.length\n    for (;; end--) {\n      let next = this.items.get(end - 1)\n      if (next.selection) { --end; break }\n    }\n\n    let remap, mapFrom\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length)\n      mapFrom = remap.maps.length\n    }\n    let transform = state.tr\n    let selection, remaining\n    let addAfter = [], addBefore = []\n\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1)\n          mapFrom = remap.maps.length\n        }\n        mapFrom--\n        addBefore.push(item)\n        return\n      }\n\n      if (remap) {\n        addBefore.push(new Item(item.map))\n        let step = item.step.map(remap.slice(mapFrom)), map\n\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1]\n          addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length))\n        }\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n      } else {\n        transform.maybeStep(item.step)\n      }\n\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1)\n        return false\n      }\n    }, this.items.length, 0)\n\n    return {remaining, transform, selection}\n  }\n\n  // : (Transform, ?SelectionBookmark, Object) \u2192 Branch\n  // Create a new branch with the given transform added.\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [], eventCount = this.eventCount\n    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null\n\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i])\n      let item = new Item(transform.mapping.maps[i], step, selection), merged\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged\n        if (i) newItems.pop()\n        else oldItems = oldItems.slice(0, oldItems.length - 1)\n      }\n      newItems.push(item)\n      if (selection) {\n        eventCount++\n        selection = null\n      }\n      if (!preserveItems) lastItem = item\n    }\n    let overflow = eventCount - histOptions.depth\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow)\n      eventCount -= overflow\n    }\n    return new Branch(oldItems.append(newItems), eventCount)\n  }\n\n  remapping(from, to) {\n    let maps = new Mapping\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n          ? maps.maps.length - item.mirrorOffset : null\n      maps.appendMap(item.map, mirrorPos)\n    }, from, to)\n    return maps\n  }\n\n  addMaps(array) {\n    if (this.eventCount == 0) return this\n    return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount)\n  }\n\n  // : (Transform, number)\n  // When the collab module receives remote changes, the history has\n  // to know about those, so that it can adjust the steps that were\n  // rebased on top of the remote changes, and include the position\n  // maps for the remote changes in its array of items.\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount) return this\n\n    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount)\n\n    let mapping = rebasedTransform.mapping\n    let newUntil = rebasedTransform.steps.length\n    let eventCount = this.eventCount\n    this.items.forEach(item => { if (item.selection) eventCount-- }, start)\n\n    let iRebased = rebasedCount\n    this.items.forEach(item => {\n      let pos = mapping.getMirror(--iRebased)\n      if (pos == null) return\n      newUntil = Math.min(newUntil, pos)\n      let map = mapping.maps[pos]\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos])\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos))\n        if (selection) eventCount++\n        rebasedItems.push(new Item(map, step, selection))\n      } else {\n        rebasedItems.push(new Item(map))\n      }\n    }, start)\n\n    let newMaps = []\n    for (let i = rebasedCount; i < newUntil; i++)\n      newMaps.push(new Item(mapping.maps[i]))\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems)\n    let branch = new Branch(items, eventCount)\n\n    if (branch.emptyItemCount() > max_empty_items)\n      branch = branch.compress(this.items.length - rebasedItems.length)\n    return branch\n  }\n\n  emptyItemCount() {\n    let count = 0\n    this.items.forEach(item => { if (!item.step) count++ })\n    return count\n  }\n\n  // Compressing a branch means rewriting it to push the air (map-only\n  // items) out. During collaboration, these naturally accumulate\n  // because each remote change adds one. The `upto` argument is used\n  // to ensure that only the items below a given level are compressed,\n  // because `rebased` relies on a clean, untouched set of items in\n  // order to associate old items with rebased steps.\n  compress(upto = this.items.length) {\n    let remap = this.remapping(0, upto), mapFrom = remap.maps.length\n    let items = [], events = 0\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item)\n        if (item.selection) events++\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap()\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom))\n          if (selection) events++\n          let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1\n          if (merged = items.length && items[last].merge(newItem))\n            items[last] = merged\n          else\n            items.push(newItem)\n        }\n      } else if (item.map) {\n        mapFrom--\n      }\n    }, this.items.length, 0)\n    return new Branch(RopeSequence.from(items.reverse()), events)\n  }\n}\n\nBranch.empty = new Branch(RopeSequence.empty, 0)\n\nfunction cutOffEvents(items, n) {\n  let cutPoint\n  items.forEach((item, i) => {\n    if (item.selection && (n-- == 0)) {\n      cutPoint = i\n      return false\n    }\n  })\n  return items.slice(cutPoint)\n}\n\nclass Item {\n  constructor(map, step, selection, mirrorOffset) {\n    // The (forward) step map for this item.\n    this.map = map\n    // The inverted step\n    this.step = step\n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    this.selection = selection\n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    this.mirrorOffset = mirrorOffset\n  }\n\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step)\n      if (step) return new Item(step.getMap().invert(), step, this.selection)\n    }\n  }\n}\n\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nexport class HistoryState {\n  constructor(done, undone, prevRanges, prevTime) {\n    this.done = done\n    this.undone = undone\n    this.prevRanges = prevRanges\n    this.prevTime = prevTime\n  }\n}\n\nconst DEPTH_OVERFLOW = 20\n\n// : (HistoryState, EditorState, Transaction, Object)\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey), rebased\n  if (historyTr) return historyTr.historyState\n\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0)\n\n  let appended = tr.getMeta(\"appendedTransaction\")\n\n  if (tr.steps.length == 0) {\n    return history\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo)\n      return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),\n                              history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime)\n    else\n      return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),\n                              null, history.prevTime)\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n                                                          !isAdjacentTo(tr, history.prevRanges))\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1])\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,\n                                                      options, mustPreserveItems(state)),\n                            Branch.empty, prevRanges, tr.time)\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased),\n                            history.undone.rebased(tr, rebased),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps),\n                            history.undone.addMaps(tr.mapping.maps),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false\n  if (!transform.docChanged) return true\n  let adjacent = false\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2)\n      if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n        adjacent = true\n  })\n  return adjacent\n}\n\nfunction rangesFor(map) {\n  let result = []\n  map.forEach((_from, _to, from, to) => result.push(from, to))\n  return result\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null\n  let result = []\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1)\n    if (from <= to) result.push(from, to)\n  }\n  return result\n}\n\n// : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  let preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems)\n  if (!pop) return\n\n  let selection = pop.selection.resolve(pop.transform.doc)\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),\n                                                                  histOptions, preserveItems)\n\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0)\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo, historyState: newHist}).scrollIntoView())\n}\n\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false\n    cachedPreserveItemsPlugins = plugins\n    for (let i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true\n      break\n    }\n  }\n  return cachedPreserveItems\n}\n\n// :: (Transaction) \u2192 Transaction\n// Set a flag on the given transaction that will prevent further steps\n// from being appended to an existing history event (so that they\n// require a separate undo command to undo).\nexport function closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true)\n}\n\nconst historyKey = new PluginKey(\"history\")\nconst closeHistoryKey = new PluginKey(\"closeHistory\")\n\n// :: (?Object) \u2192 Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which can be used with the\n// [`undo`](#history.undo) and [`redo`](#history.redo) commands.\n//\n// You can set an `\"addToHistory\"` [metadata\n// property](#state.Transaction.setMeta) of `false` on a transaction\n// to prevent it from being rolled back by undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: ?number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\nexport function history(config) {\n  config = {depth: config && config.depth || 100,\n            newGroupDelay: config && config.newGroupDelay || 500}\n  return new Plugin({\n    key: historyKey,\n\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0)\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config)\n      }\n    },\n\n    config\n  })\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// A command function that undoes the last change, if any.\nexport function undo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.done.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, false)\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// A command function that redoes the last undone change, if any.\nexport function redo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.undone.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, true)\n  return true\n}\n\n// :: (EditorState) \u2192 number\n// The amount of undoable events available in a given state.\nexport function undoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.done.eventCount : 0\n}\n\n// :: (EditorState) \u2192 number\n// The amount of redoable events available in a given editor state.\nexport function redoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.undone.eventCount : 0\n}\n"],
  "mappings": "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",
  "names": []
}
