import {
  index_es_exports as index_es_exports3,
  init_index_es as init_index_es3
} from "./chunk-3GJDBDX5.js";
import "./chunk-GSCWWJLB.js";
import {
  index_es_exports as index_es_exports2,
  init_index_es as init_index_es2
} from "./chunk-37MHF4IQ.js";
import "./chunk-YWSQD36O.js";
import {
  index_es_exports,
  init_index_es
} from "./chunk-R7NIYD52.js";
import {
  __commonJS
} from "./chunk-A5ICIBVI.js";

// ../node_modules/prosemirror-utils/dist/index.js
var require_dist = __commonJS({
  "../node_modules/prosemirror-utils/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var prosemirrorState = (init_index_es2(), index_es_exports2);
    var prosemirrorModel = (init_index_es(), index_es_exports);
    var prosemirrorTables = (init_index_es3(), index_es_exports3);
    var removeParentNodeOfType = function removeParentNodeOfType2(nodeType) {
      return function(tr) {
        var parent = findParentNodeOfType(nodeType)(tr.selection);
        if (parent) {
          return removeNodeAtPos(parent.pos)(tr);
        }
        return tr;
      };
    };
    var replaceParentNodeOfType = function replaceParentNodeOfType2(nodeType, content) {
      return function(tr) {
        if (!Array.isArray(nodeType)) {
          nodeType = [nodeType];
        }
        for (var i = 0, count = nodeType.length; i < count; i++) {
          var parent = findParentNodeOfType(nodeType[i])(tr.selection);
          if (parent) {
            var newTr = replaceNodeAtPos(parent.pos, content)(tr);
            if (newTr !== tr) {
              return newTr;
            }
          }
        }
        return tr;
      };
    };
    var removeSelectedNode = function removeSelectedNode2(tr) {
      if (isNodeSelection(tr.selection)) {
        var from = tr.selection.$from.pos;
        var to = tr.selection.$to.pos;
        return cloneTr(tr.delete(from, to));
      }
      return tr;
    };
    var replaceSelectedNode = function replaceSelectedNode2(content) {
      return function(tr) {
        if (isNodeSelection(tr.selection)) {
          var _tr$selection = tr.selection, $from = _tr$selection.$from, $to = _tr$selection.$to;
          if (content instanceof prosemirrorModel.Fragment && $from.parent.canReplace($from.index(), $from.indexAfter(), content) || $from.parent.canReplaceWith($from.index(), $from.indexAfter(), content.type)) {
            return cloneTr(tr.replaceWith($from.pos, $to.pos, content).setSelection(new prosemirrorState.NodeSelection(tr.doc.resolve($from.pos))));
          }
        }
        return tr;
      };
    };
    var setTextSelection = function setTextSelection2(position) {
      var dir = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      return function(tr) {
        var nextSelection = prosemirrorState.Selection.findFrom(tr.doc.resolve(position), dir, true);
        if (nextSelection) {
          return tr.setSelection(nextSelection);
        }
        return tr;
      };
    };
    var isSelectableNode = function isSelectableNode2(node) {
      return node.type && node.type.spec.selectable;
    };
    var shouldSelectNode = function shouldSelectNode2(node) {
      return isSelectableNode(node) && node.type.isLeaf;
    };
    var setSelection = function setSelection2(node, pos, tr) {
      if (shouldSelectNode(node)) {
        return tr.setSelection(new prosemirrorState.NodeSelection(tr.doc.resolve(pos)));
      }
      return setTextSelection(pos)(tr);
    };
    var safeInsert = function safeInsert2(content, position, tryToReplace) {
      return function(tr) {
        var hasPosition = typeof position === "number";
        var $from = tr.selection.$from;
        var $insertPos = hasPosition ? tr.doc.resolve(position) : isNodeSelection(tr.selection) ? tr.doc.resolve($from.pos + 1) : $from;
        var parent = $insertPos.parent;
        if (isNodeSelection(tr.selection) && tryToReplace) {
          var oldTr = tr;
          tr = replaceSelectedNode(content)(tr);
          if (oldTr !== tr) {
            return tr;
          }
        }
        if (isEmptyParagraph(parent)) {
          var _oldTr = tr;
          tr = replaceParentNodeOfType(parent.type, content)(tr);
          if (_oldTr !== tr) {
            var pos = isSelectableNode(content) ? $insertPos.before($insertPos.depth) : $insertPos.pos;
            return setSelection(content, pos, tr);
          }
        }
        if (canInsert($insertPos, content)) {
          tr.insert($insertPos.pos, content);
          var _pos = hasPosition ? $insertPos.pos : isSelectableNode(content) ? tr.selection.$anchor.pos - 1 : tr.selection.$anchor.pos;
          return cloneTr(setSelection(content, _pos, tr));
        }
        for (var i = $insertPos.depth; i > 0; i--) {
          var _pos2 = $insertPos.after(i);
          var $pos = tr.doc.resolve(_pos2);
          if (canInsert($pos, content)) {
            tr.insert(_pos2, content);
            return cloneTr(setSelection(content, _pos2, tr));
          }
        }
        return tr;
      };
    };
    var setParentNodeMarkup = function setParentNodeMarkup2(nodeType, type, attrs, marks) {
      return function(tr) {
        var parent = findParentNodeOfType(nodeType)(tr.selection);
        if (parent) {
          return cloneTr(tr.setNodeMarkup(parent.pos, type, Object.assign({}, parent.node.attrs, attrs), marks));
        }
        return tr;
      };
    };
    var selectParentNodeOfType = function selectParentNodeOfType2(nodeType) {
      return function(tr) {
        if (!isNodeSelection(tr.selection)) {
          var parent = findParentNodeOfType(nodeType)(tr.selection);
          if (parent) {
            return cloneTr(tr.setSelection(prosemirrorState.NodeSelection.create(tr.doc, parent.pos)));
          }
        }
        return tr;
      };
    };
    var removeNodeBefore = function removeNodeBefore2(tr) {
      var position = findPositionOfNodeBefore(tr.selection);
      if (typeof position === "number") {
        return removeNodeAtPos(position)(tr);
      }
      return tr;
    };
    var isNodeSelection = function isNodeSelection2(selection) {
      return selection instanceof prosemirrorState.NodeSelection;
    };
    var equalNodeType = function equalNodeType2(nodeType, node) {
      return Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1 || node.type === nodeType;
    };
    var cloneTr = function cloneTr2(tr) {
      return Object.assign(Object.create(tr), tr).setTime(Date.now());
    };
    var replaceNodeAtPos = function replaceNodeAtPos2(position, content) {
      return function(tr) {
        var node = tr.doc.nodeAt(position);
        var $pos = tr.doc.resolve(position);
        if (canReplace($pos, content)) {
          tr = tr.replaceWith(position, position + node.nodeSize, content);
          var start = tr.selection.$from.pos - 1;
          tr = setTextSelection(Math.max(start, 0), -1)(tr);
          tr = setTextSelection(tr.selection.$from.start())(tr);
          return cloneTr(tr);
        }
        return tr;
      };
    };
    var canReplace = function canReplace2($pos, content) {
      var node = $pos.node($pos.depth);
      return node && node.type.validContent(content instanceof prosemirrorModel.Fragment ? content : prosemirrorModel.Fragment.from(content));
    };
    var removeNodeAtPos = function removeNodeAtPos2(position) {
      return function(tr) {
        var node = tr.doc.nodeAt(position);
        return cloneTr(tr.delete(position, position + node.nodeSize));
      };
    };
    var tableNodeTypes = function tableNodeTypes2(schema) {
      if (schema.cached.tableNodeTypes) {
        return schema.cached.tableNodeTypes;
      }
      var roles = {};
      Object.keys(schema.nodes).forEach(function(type) {
        var nodeType = schema.nodes[type];
        if (nodeType.spec.tableRole) {
          roles[nodeType.spec.tableRole] = nodeType;
        }
      });
      schema.cached.tableNodeTypes = roles;
      return roles;
    };
    var canInsert = function canInsert2($pos, content) {
      var index = $pos.index();
      if (content instanceof prosemirrorModel.Fragment) {
        return $pos.parent.canReplace(index, index, content);
      } else if (content instanceof prosemirrorModel.Node) {
        return $pos.parent.canReplaceWith(index, index, content.type);
      }
      return false;
    };
    var isEmptyParagraph = function isEmptyParagraph2(node) {
      return !node || node.type.name === "paragraph" && node.nodeSize === 2;
    };
    var findTableClosestToPos = function findTableClosestToPos2($pos) {
      var predicate = function predicate2(node) {
        return node.type.spec.tableRole && /table/i.test(node.type.spec.tableRole);
      };
      return findParentNodeClosestToPos($pos, predicate);
    };
    var createCell = function createCell2(cellType) {
      var cellContent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (cellContent) {
        return cellType.createChecked(null, cellContent);
      }
      return cellType.createAndFill();
    };
    var isRectSelected = function isRectSelected2(rect) {
      return function(selection) {
        var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));
        var start = selection.$anchorCell.start(-1);
        var cells = map.cellsInRect(rect);
        var selectedCells = map.cellsInRect(map.rectBetween(selection.$anchorCell.pos - start, selection.$headCell.pos - start));
        for (var i = 0, count = cells.length; i < count; i++) {
          if (selectedCells.indexOf(cells[i]) === -1) {
            return false;
          }
        }
        return true;
      };
    };
    var transpose = function transpose2(array) {
      return array[0].map(function(_, i) {
        return array.map(function(column) {
          return column[i];
        });
      });
    };
    var convertTableNodeToArrayOfRows = function convertTableNodeToArrayOfRows2(tableNode) {
      var map = prosemirrorTables.TableMap.get(tableNode);
      var rows = [];
      for (var rowIndex = 0; rowIndex < map.height; rowIndex++) {
        var rowCells = [];
        var seen = {};
        for (var colIndex = 0; colIndex < map.width; colIndex++) {
          var cellPos = map.map[rowIndex * map.width + colIndex];
          var cell = tableNode.nodeAt(cellPos);
          var rect = map.findCell(cellPos);
          if (seen[cellPos] || rect.top !== rowIndex) {
            rowCells.push(null);
            continue;
          }
          seen[cellPos] = true;
          rowCells.push(cell);
        }
        rows.push(rowCells);
      }
      return rows;
    };
    var convertArrayOfRowsToTableNode = function convertArrayOfRowsToTableNode2(tableNode, arrayOfNodes) {
      var rowsPM = [];
      var map = prosemirrorTables.TableMap.get(tableNode);
      for (var rowIndex = 0; rowIndex < map.height; rowIndex++) {
        var row = tableNode.child(rowIndex);
        var rowCells = [];
        for (var colIndex = 0; colIndex < map.width; colIndex++) {
          if (!arrayOfNodes[rowIndex][colIndex]) {
            continue;
          }
          var cellPos = map.map[rowIndex * map.width + colIndex];
          var cell = arrayOfNodes[rowIndex][colIndex];
          var oldCell = tableNode.nodeAt(cellPos);
          var newCell = oldCell.type.createChecked(Object.assign({}, cell.attrs), cell.content, cell.marks);
          rowCells.push(newCell);
        }
        rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks));
      }
      var newTable = tableNode.type.createChecked(tableNode.attrs, rowsPM, tableNode.marks);
      return newTable;
    };
    var moveTableColumn = function moveTableColumn2(table, indexesOrigin, indexesTarget, direction) {
      var rows = transpose(convertTableNodeToArrayOfRows(table.node));
      rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);
      rows = transpose(rows);
      return convertArrayOfRowsToTableNode(table.node, rows);
    };
    var moveTableRow = function moveTableRow2(table, indexesOrigin, indexesTarget, direction) {
      var rows = convertTableNodeToArrayOfRows(table.node);
      rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);
      return convertArrayOfRowsToTableNode(table.node, rows);
    };
    var moveRowInArrayOfRows = function moveRowInArrayOfRows2(rows, indexesOrigin, indexesTarget, directionOverride) {
      var direction = indexesOrigin[0] > indexesTarget[0] ? -1 : 1;
      var rowsExtracted = rows.splice(indexesOrigin[0], indexesOrigin.length);
      var positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0;
      var target = void 0;
      if (directionOverride === -1 && direction === 1) {
        target = indexesTarget[0] - 1;
      } else if (directionOverride === 1 && direction === -1) {
        target = indexesTarget[indexesTarget.length - 1] - positionOffset + 1;
      } else {
        target = direction === -1 ? indexesTarget[0] : indexesTarget[indexesTarget.length - 1] - positionOffset;
      }
      rows.splice.apply(rows, [target, 0].concat(rowsExtracted));
      return rows;
    };
    var checkInvalidMovements = function checkInvalidMovements2(originIndex, targetIndex, targets, type) {
      var direction = originIndex > targetIndex ? -1 : 1;
      var errorMessage = "Target position is invalid, you can't move the " + type + " " + originIndex + " to " + targetIndex + ", the target can't be split. You could use tryToFit option.";
      if (direction === 1) {
        if (targets.slice(0, targets.length - 1).indexOf(targetIndex) !== -1) {
          throw new Error(errorMessage);
        }
      } else {
        if (targets.slice(1).indexOf(targetIndex) !== -1) {
          throw new Error(errorMessage);
        }
      }
      return true;
    };
    var findParentNode = function findParentNode2(predicate) {
      return function(_ref) {
        var $from = _ref.$from;
        return findParentNodeClosestToPos($from, predicate);
      };
    };
    var findParentNodeClosestToPos = function findParentNodeClosestToPos2($pos, predicate) {
      for (var i = $pos.depth; i > 0; i--) {
        var node = $pos.node(i);
        if (predicate(node)) {
          return {
            pos: i > 0 ? $pos.before(i) : 0,
            start: $pos.start(i),
            depth: i,
            node
          };
        }
      }
    };
    var findParentDomRef = function findParentDomRef2(predicate, domAtPos) {
      return function(selection) {
        var parent = findParentNode(predicate)(selection);
        if (parent) {
          return findDomRefAtPos(parent.pos, domAtPos);
        }
      };
    };
    var hasParentNode = function hasParentNode2(predicate) {
      return function(selection) {
        return !!findParentNode(predicate)(selection);
      };
    };
    var findParentNodeOfType = function findParentNodeOfType2(nodeType) {
      return function(selection) {
        return findParentNode(function(node) {
          return equalNodeType(nodeType, node);
        })(selection);
      };
    };
    var findParentNodeOfTypeClosestToPos = function findParentNodeOfTypeClosestToPos2($pos, nodeType) {
      return findParentNodeClosestToPos($pos, function(node) {
        return equalNodeType(nodeType, node);
      });
    };
    var hasParentNodeOfType = function hasParentNodeOfType2(nodeType) {
      return function(selection) {
        return hasParentNode(function(node) {
          return equalNodeType(nodeType, node);
        })(selection);
      };
    };
    var findParentDomRefOfType = function findParentDomRefOfType2(nodeType, domAtPos) {
      return function(selection) {
        return findParentDomRef(function(node) {
          return equalNodeType(nodeType, node);
        }, domAtPos)(selection);
      };
    };
    var findSelectedNodeOfType = function findSelectedNodeOfType2(nodeType) {
      return function(selection) {
        if (isNodeSelection(selection)) {
          var node = selection.node, $from = selection.$from;
          if (equalNodeType(nodeType, node)) {
            return { node, pos: $from.pos, depth: $from.depth };
          }
        }
      };
    };
    var findPositionOfNodeBefore = function findPositionOfNodeBefore2(selection) {
      var nodeBefore = selection.$from.nodeBefore;
      var maybeSelection = prosemirrorState.Selection.findFrom(selection.$from, -1);
      if (maybeSelection && nodeBefore) {
        var parent = findParentNodeOfType(nodeBefore.type)(maybeSelection);
        if (parent) {
          return parent.pos;
        }
        return maybeSelection.$from.pos;
      }
    };
    var findDomRefAtPos = function findDomRefAtPos2(position, domAtPos) {
      var dom = domAtPos(position);
      var node = dom.node.childNodes[dom.offset];
      if (dom.node.nodeType === Node.TEXT_NODE) {
        return dom.node.parentNode;
      }
      if (!node || node.nodeType === Node.TEXT_NODE) {
        return dom.node;
      }
      return node;
    };
    var flatten = function flatten2(node) {
      var descend = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (!node) {
        throw new Error('Invalid "node" parameter');
      }
      var result = [];
      node.descendants(function(child, pos) {
        result.push({ node: child, pos });
        if (!descend) {
          return false;
        }
      });
      return result;
    };
    var findChildren = function findChildren2(node, predicate, descend) {
      if (!node) {
        throw new Error('Invalid "node" parameter');
      } else if (!predicate) {
        throw new Error('Invalid "predicate" parameter');
      }
      return flatten(node, descend).filter(function(child) {
        return predicate(child.node);
      });
    };
    var findTextNodes = function findTextNodes2(node, descend) {
      return findChildren(node, function(child) {
        return child.isText;
      }, descend);
    };
    var findInlineNodes = function findInlineNodes2(node, descend) {
      return findChildren(node, function(child) {
        return child.isInline;
      }, descend);
    };
    var findBlockNodes = function findBlockNodes2(node, descend) {
      return findChildren(node, function(child) {
        return child.isBlock;
      }, descend);
    };
    var findChildrenByAttr = function findChildrenByAttr2(node, predicate, descend) {
      return findChildren(node, function(child) {
        return !!predicate(child.attrs);
      }, descend);
    };
    var findChildrenByType = function findChildrenByType2(node, nodeType, descend) {
      return findChildren(node, function(child) {
        return child.type === nodeType;
      }, descend);
    };
    var findChildrenByMark = function findChildrenByMark2(node, markType, descend) {
      return findChildren(node, function(child) {
        return markType.isInSet(child.marks);
      }, descend);
    };
    var contains = function contains2(node, nodeType) {
      return !!findChildrenByType(node, nodeType).length;
    };
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var findTable = function findTable2(selection) {
      return findParentNode(function(node) {
        return node.type.spec.tableRole && node.type.spec.tableRole === "table";
      })(selection);
    };
    var isCellSelection = function isCellSelection2(selection) {
      return selection instanceof prosemirrorTables.CellSelection;
    };
    var getSelectionRect = function getSelectionRect2(selection) {
      if (!isCellSelection(selection)) {
        return;
      }
      var start = selection.$anchorCell.start(-1);
      var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));
      return map.rectBetween(selection.$anchorCell.pos - start, selection.$headCell.pos - start);
    };
    var isColumnSelected = function isColumnSelected2(columnIndex) {
      return function(selection) {
        if (isCellSelection(selection)) {
          var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));
          return isRectSelected({
            left: columnIndex,
            right: columnIndex + 1,
            top: 0,
            bottom: map.height
          })(selection);
        }
        return false;
      };
    };
    var isRowSelected = function isRowSelected2(rowIndex) {
      return function(selection) {
        if (isCellSelection(selection)) {
          var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));
          return isRectSelected({
            left: 0,
            right: map.width,
            top: rowIndex,
            bottom: rowIndex + 1
          })(selection);
        }
        return false;
      };
    };
    var isTableSelected = function isTableSelected2(selection) {
      if (isCellSelection(selection)) {
        var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));
        return isRectSelected({
          left: 0,
          right: map.width,
          top: 0,
          bottom: map.height
        })(selection);
      }
      return false;
    };
    var getCellsInColumn = function getCellsInColumn2(columnIndex) {
      return function(selection) {
        var table = findTable(selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          var indexes = Array.isArray(columnIndex) ? columnIndex : Array.from([columnIndex]);
          return indexes.reduce(function(acc, index) {
            if (index >= 0 && index <= map.width - 1) {
              var cells = map.cellsInRect({
                left: index,
                right: index + 1,
                top: 0,
                bottom: map.height
              });
              return acc.concat(cells.map(function(nodePos) {
                var node = table.node.nodeAt(nodePos);
                var pos = nodePos + table.start;
                return { pos, start: pos + 1, node };
              }));
            }
          }, []);
        }
      };
    };
    var getCellsInRow = function getCellsInRow2(rowIndex) {
      return function(selection) {
        var table = findTable(selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          var indexes = Array.isArray(rowIndex) ? rowIndex : Array.from([rowIndex]);
          return indexes.reduce(function(acc, index) {
            if (index >= 0 && index <= map.height - 1) {
              var cells = map.cellsInRect({
                left: 0,
                right: map.width,
                top: index,
                bottom: index + 1
              });
              return acc.concat(cells.map(function(nodePos) {
                var node = table.node.nodeAt(nodePos);
                var pos = nodePos + table.start;
                return { pos, start: pos + 1, node };
              }));
            }
          }, []);
        }
      };
    };
    var getCellsInTable = function getCellsInTable2(selection) {
      var table = findTable(selection);
      if (table) {
        var map = prosemirrorTables.TableMap.get(table.node);
        var cells = map.cellsInRect({
          left: 0,
          right: map.width,
          top: 0,
          bottom: map.height
        });
        return cells.map(function(nodePos) {
          var node = table.node.nodeAt(nodePos);
          var pos = nodePos + table.start;
          return { pos, start: pos + 1, node };
        });
      }
    };
    var select = function select2(type) {
      return function(index, expand) {
        return function(tr) {
          var table = findTable(tr.selection);
          var isRowSelection = type === "row";
          if (table) {
            var map = prosemirrorTables.TableMap.get(table.node);
            if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {
              var left = isRowSelection ? 0 : index;
              var top = isRowSelection ? index : 0;
              var right = isRowSelection ? map.width : index + 1;
              var bottom = isRowSelection ? index + 1 : map.height;
              if (expand) {
                var cell = findCellClosestToPos(tr.selection.$from);
                if (!cell) {
                  return tr;
                }
                var selRect = map.findCell(cell.pos - table.start);
                if (isRowSelection) {
                  top = Math.min(top, selRect.top);
                  bottom = Math.max(bottom, selRect.bottom);
                } else {
                  left = Math.min(left, selRect.left);
                  right = Math.max(right, selRect.right);
                }
              }
              var cellsInFirstRow = map.cellsInRect({
                left,
                top,
                right: isRowSelection ? right : left + 1,
                bottom: isRowSelection ? top + 1 : bottom
              });
              var cellsInLastRow = bottom - top === 1 ? cellsInFirstRow : map.cellsInRect({
                left: isRowSelection ? left : right - 1,
                top: isRowSelection ? bottom - 1 : top,
                right,
                bottom
              });
              var head = table.start + cellsInFirstRow[0];
              var anchor = table.start + cellsInLastRow[cellsInLastRow.length - 1];
              var $head = tr.doc.resolve(head);
              var $anchor = tr.doc.resolve(anchor);
              return cloneTr(tr.setSelection(new prosemirrorTables.CellSelection($anchor, $head)));
            }
          }
          return tr;
        };
      };
    };
    var selectColumn = select("column");
    var selectRow = select("row");
    var selectTable = function selectTable2(tr) {
      var table = findTable(tr.selection);
      if (table) {
        var _TableMap$get = prosemirrorTables.TableMap.get(table.node), map = _TableMap$get.map;
        if (map && map.length) {
          var head = table.start + map[0];
          var anchor = table.start + map[map.length - 1];
          var $head = tr.doc.resolve(head);
          var $anchor = tr.doc.resolve(anchor);
          return cloneTr(tr.setSelection(new prosemirrorTables.CellSelection($anchor, $head)));
        }
      }
      return tr;
    };
    var emptyCell = function emptyCell2(cell, schema) {
      return function(tr) {
        if (cell) {
          var _tableNodeTypes$cell$ = tableNodeTypes(schema).cell.createAndFill(), content = _tableNodeTypes$cell$.content;
          if (!cell.node.content.eq(content)) {
            tr.replaceWith(cell.pos + 1, cell.pos + cell.node.nodeSize, content);
            return cloneTr(tr);
          }
        }
        return tr;
      };
    };
    var addColumnAt = function addColumnAt2(columnIndex) {
      return function(tr) {
        var table = findTable(tr.selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          if (columnIndex >= 0 && columnIndex <= map.width) {
            return cloneTr(prosemirrorTables.addColumn(tr, {
              map,
              tableStart: table.start,
              table: table.node
            }, columnIndex));
          }
        }
        return tr;
      };
    };
    var moveRow = function moveRow2(originRowIndex, targetRowIndex, opts) {
      return function(tr) {
        var defaultOptions = { tryToFit: false, direction: 0 };
        var options = Object.assign(defaultOptions, opts);
        var table = findTable(tr.selection);
        if (!table) {
          return tr;
        }
        var _getSelectionRangeInR = getSelectionRangeInRow(originRowIndex)(tr), indexesOriginRow = _getSelectionRangeInR.indexes;
        var _getSelectionRangeInR2 = getSelectionRangeInRow(targetRowIndex)(tr), indexesTargetRow = _getSelectionRangeInR2.indexes;
        if (indexesOriginRow.indexOf(targetRowIndex) > -1) {
          return tr;
        }
        if (!options.tryToFit && indexesTargetRow.length > 1) {
          checkInvalidMovements(originRowIndex, targetRowIndex, indexesTargetRow, "row");
        }
        var newTable = moveTableRow(table, indexesOriginRow, indexesTargetRow, options.direction);
        return cloneTr(tr).replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);
      };
    };
    var moveColumn = function moveColumn2(originColumnIndex, targetColumnIndex, opts) {
      return function(tr) {
        var defaultOptions = { tryToFit: false, direction: 0 };
        var options = Object.assign(defaultOptions, opts);
        var table = findTable(tr.selection);
        if (!table) {
          return tr;
        }
        var _getSelectionRangeInC = getSelectionRangeInColumn(originColumnIndex)(tr), indexesOriginColumn = _getSelectionRangeInC.indexes;
        var _getSelectionRangeInC2 = getSelectionRangeInColumn(targetColumnIndex)(tr), indexesTargetColumn = _getSelectionRangeInC2.indexes;
        if (indexesOriginColumn.indexOf(targetColumnIndex) > -1) {
          return tr;
        }
        if (!options.tryToFit && indexesTargetColumn.length > 1) {
          checkInvalidMovements(originColumnIndex, targetColumnIndex, indexesTargetColumn, "column");
        }
        var newTable = moveTableColumn(table, indexesOriginColumn, indexesTargetColumn, options.direction);
        return cloneTr(tr).replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);
      };
    };
    var addRowAt = function addRowAt2(rowIndex, clonePreviousRow) {
      return function(tr) {
        var table = findTable(tr.selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          var cloneRowIndex = rowIndex - 1;
          if (clonePreviousRow && cloneRowIndex >= 0) {
            return cloneTr(cloneRowAt(cloneRowIndex)(tr));
          }
          if (rowIndex >= 0 && rowIndex <= map.height) {
            return cloneTr(prosemirrorTables.addRow(tr, {
              map,
              tableStart: table.start,
              table: table.node
            }, rowIndex));
          }
        }
        return tr;
      };
    };
    var cloneRowAt = function cloneRowAt2(rowIndex) {
      return function(tr) {
        var table = findTable(tr.selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          if (rowIndex >= 0 && rowIndex <= map.height) {
            var tableNode = table.node;
            var tableNodes = tableNodeTypes(tableNode.type.schema);
            var rowPos = table.start;
            for (var i = 0; i < rowIndex + 1; i++) {
              rowPos += tableNode.child(i).nodeSize;
            }
            var cloneRow = tableNode.child(rowIndex);
            var cells = [];
            var rowWidth = 0;
            cloneRow.forEach(function(cell) {
              if (cell.attrs.rowspan === 1) {
                rowWidth += cell.attrs.colspan;
                cells.push(tableNodes[cell.type.spec.tableRole].createAndFill(cell.attrs, cell.marks));
              }
            });
            if (rowWidth < map.width) {
              var rowSpanCells = [];
              var _loop = function _loop2(_i2) {
                var foundCells = filterCellsInRow(_i2, function(cell, tr2) {
                  var rowspan = cell.node.attrs.rowspan;
                  var spanRange = _i2 + rowspan;
                  return rowspan > 1 && spanRange > rowIndex;
                })(tr);
                rowSpanCells.push.apply(rowSpanCells, _toConsumableArray(foundCells));
              };
              for (var _i = rowIndex; _i >= 0; _i--) {
                _loop(_i);
              }
              if (rowSpanCells.length) {
                rowSpanCells.forEach(function(cell) {
                  tr = setCellAttrs(cell, {
                    rowspan: cell.node.attrs.rowspan + 1
                  })(tr);
                });
              }
            }
            return safeInsert(tableNodes.row.create(cloneRow.attrs, cells), rowPos)(tr);
          }
        }
        return tr;
      };
    };
    var removeColumnAt = function removeColumnAt2(columnIndex) {
      return function(tr) {
        var table = findTable(tr.selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          if (columnIndex === 0 && map.width === 1) {
            return removeTable(tr);
          } else if (columnIndex >= 0 && columnIndex <= map.width) {
            prosemirrorTables.removeColumn(tr, {
              map,
              tableStart: table.start,
              table: table.node
            }, columnIndex);
            return cloneTr(tr);
          }
        }
        return tr;
      };
    };
    var removeRowAt = function removeRowAt2(rowIndex) {
      return function(tr) {
        var table = findTable(tr.selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          if (rowIndex === 0 && map.height === 1) {
            return removeTable(tr);
          } else if (rowIndex >= 0 && rowIndex <= map.height) {
            prosemirrorTables.removeRow(tr, {
              map,
              tableStart: table.start,
              table: table.node
            }, rowIndex);
            return cloneTr(tr);
          }
        }
        return tr;
      };
    };
    var removeTable = function removeTable2(tr) {
      var $from = tr.selection.$from;
      for (var depth = $from.depth; depth > 0; depth--) {
        var node = $from.node(depth);
        if (node.type.spec.tableRole === "table") {
          return cloneTr(tr.delete($from.before(depth), $from.after(depth)));
        }
      }
      return tr;
    };
    var removeSelectedColumns = function removeSelectedColumns2(tr) {
      var selection = tr.selection;
      if (isTableSelected(selection)) {
        return removeTable(tr);
      }
      if (isCellSelection(selection)) {
        var table = findTable(selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          var rect = map.rectBetween(selection.$anchorCell.pos - table.start, selection.$headCell.pos - table.start);
          if (rect.left == 0 && rect.right == map.width) {
            return false;
          }
          var pmTableRect = Object.assign({}, rect, {
            map,
            table: table.node,
            tableStart: table.start
          });
          for (var i = pmTableRect.right - 1; ; i--) {
            prosemirrorTables.removeColumn(tr, pmTableRect, i);
            if (i === pmTableRect.left) {
              break;
            }
            pmTableRect.table = pmTableRect.tableStart ? tr.doc.nodeAt(pmTableRect.tableStart - 1) : tr.doc;
            pmTableRect.map = prosemirrorTables.TableMap.get(pmTableRect.table);
          }
          return cloneTr(tr);
        }
      }
      return tr;
    };
    var removeSelectedRows = function removeSelectedRows2(tr) {
      var selection = tr.selection;
      if (isTableSelected(selection)) {
        return removeTable(tr);
      }
      if (isCellSelection(selection)) {
        var table = findTable(selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          var rect = map.rectBetween(selection.$anchorCell.pos - table.start, selection.$headCell.pos - table.start);
          if (rect.top == 0 && rect.bottom == map.height) {
            return false;
          }
          var pmTableRect = Object.assign({}, rect, {
            map,
            table: table.node,
            tableStart: table.start
          });
          for (var i = pmTableRect.bottom - 1; ; i--) {
            prosemirrorTables.removeRow(tr, pmTableRect, i);
            if (i === pmTableRect.top) {
              break;
            }
            pmTableRect.table = pmTableRect.tableStart ? tr.doc.nodeAt(pmTableRect.tableStart - 1) : tr.doc;
            pmTableRect.map = prosemirrorTables.TableMap.get(pmTableRect.table);
          }
          return cloneTr(tr);
        }
      }
      return tr;
    };
    var removeColumnClosestToPos = function removeColumnClosestToPos2($pos) {
      return function(tr) {
        var rect = findCellRectClosestToPos($pos);
        if (rect) {
          return removeColumnAt(rect.left)(setTextSelection($pos.pos)(tr));
        }
        return tr;
      };
    };
    var removeRowClosestToPos = function removeRowClosestToPos2($pos) {
      return function(tr) {
        var rect = findCellRectClosestToPos($pos);
        if (rect) {
          return removeRowAt(rect.top)(setTextSelection($pos.pos)(tr));
        }
        return tr;
      };
    };
    var forEachCellInColumn = function forEachCellInColumn2(columnIndex, cellTransform, setCursorToLastCell) {
      return function(tr) {
        var cells = getCellsInColumn(columnIndex)(tr.selection);
        if (cells) {
          for (var i = cells.length - 1; i >= 0; i--) {
            tr = cellTransform(cells[i], tr);
          }
          if (setCursorToLastCell) {
            var $pos = tr.doc.resolve(tr.mapping.map(cells[cells.length - 1].pos));
            tr.setSelection(prosemirrorState.Selection.near($pos));
          }
          return cloneTr(tr);
        }
        return tr;
      };
    };
    var forEachCellInRow = function forEachCellInRow2(rowIndex, cellTransform, setCursorToLastCell) {
      return function(tr) {
        var cells = getCellsInRow(rowIndex)(tr.selection);
        if (cells) {
          for (var i = cells.length - 1; i >= 0; i--) {
            tr = cellTransform(cells[i], tr);
          }
          if (setCursorToLastCell) {
            var $pos = tr.doc.resolve(tr.mapping.map(cells[cells.length - 1].pos));
            tr.setSelection(prosemirrorState.Selection.near($pos));
          }
        }
        return tr;
      };
    };
    var setCellAttrs = function setCellAttrs2(cell, attrs) {
      return function(tr) {
        if (cell) {
          tr.setNodeMarkup(cell.pos, null, Object.assign({}, cell.node.attrs, attrs));
          return cloneTr(tr);
        }
        return tr;
      };
    };
    var createTable = function createTable2(schema) {
      var rowsCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
      var colsCount = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
      var withHeaderRow = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var cellContent = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
      var _tableNodeTypes = tableNodeTypes(schema), tableCell = _tableNodeTypes.cell, tableHeader = _tableNodeTypes.header_cell, tableRow = _tableNodeTypes.row, table = _tableNodeTypes.table;
      var cells = [];
      var headerCells = [];
      for (var i = 0; i < colsCount; i++) {
        cells.push(createCell(tableCell, cellContent));
        if (withHeaderRow) {
          headerCells.push(createCell(tableHeader, cellContent));
        }
      }
      var rows = [];
      for (var _i2 = 0; _i2 < rowsCount; _i2++) {
        rows.push(tableRow.createChecked(null, withHeaderRow && _i2 === 0 ? headerCells : cells));
      }
      return table.createChecked(null, rows);
    };
    var findCellClosestToPos = function findCellClosestToPos2($pos) {
      var predicate = function predicate2(node) {
        return node.type.spec.tableRole && /cell/i.test(node.type.spec.tableRole);
      };
      return findParentNodeClosestToPos($pos, predicate);
    };
    var findCellRectClosestToPos = function findCellRectClosestToPos2($pos) {
      var cell = findCellClosestToPos($pos);
      if (cell) {
        var table = findTableClosestToPos($pos);
        var map = prosemirrorTables.TableMap.get(table.node);
        var cellPos = cell.pos - table.start;
        return map.rectBetween(cellPos, cellPos);
      }
    };
    var filterCellsInRow = function filterCellsInRow2(rowIndex, predicate) {
      return function(tr) {
        var foundCells = [];
        var cells = getCellsInRow(rowIndex)(tr.selection);
        if (cells) {
          for (var j = cells.length - 1; j >= 0; j--) {
            if (predicate(cells[j], tr)) {
              foundCells.push(cells[j]);
            }
          }
        }
        return foundCells;
      };
    };
    var getSelectionRangeInColumn = function getSelectionRangeInColumn2(columnIndex) {
      return function(tr) {
        var startIndex = columnIndex;
        var endIndex = columnIndex;
        var _loop2 = function _loop22(i2) {
          var cells = getCellsInColumn(i2)(tr.selection);
          if (cells) {
            cells.forEach(function(cell) {
              var maybeEndIndex = cell.node.attrs.colspan + i2 - 1;
              if (maybeEndIndex >= startIndex) {
                startIndex = i2;
              }
              if (maybeEndIndex > endIndex) {
                endIndex = maybeEndIndex;
              }
            });
          }
        };
        for (var i = columnIndex; i >= 0; i--) {
          _loop2(i);
        }
        var _loop3 = function _loop32(i2) {
          var cells = getCellsInColumn(i2)(tr.selection);
          if (cells) {
            cells.forEach(function(cell) {
              var maybeEndIndex = cell.node.attrs.colspan + i2 - 1;
              if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex) {
                endIndex = maybeEndIndex;
              }
            });
          }
        };
        for (var i = columnIndex; i <= endIndex; i++) {
          _loop3(i);
        }
        var indexes = [];
        for (var i = startIndex; i <= endIndex; i++) {
          var maybeCells = getCellsInColumn(i)(tr.selection);
          if (maybeCells && maybeCells.length) {
            indexes.push(i);
          }
        }
        startIndex = indexes[0];
        endIndex = indexes[indexes.length - 1];
        var firstSelectedColumnCells = getCellsInColumn(startIndex)(tr.selection);
        var firstRowCells = getCellsInRow(0)(tr.selection);
        var $anchor = tr.doc.resolve(firstSelectedColumnCells[firstSelectedColumnCells.length - 1].pos);
        var headCell = void 0;
        for (var _i3 = endIndex; _i3 >= startIndex; _i3--) {
          var columnCells = getCellsInColumn(_i3)(tr.selection);
          if (columnCells && columnCells.length) {
            for (var j = firstRowCells.length - 1; j >= 0; j--) {
              if (firstRowCells[j].pos === columnCells[0].pos) {
                headCell = columnCells[0];
                break;
              }
            }
            if (headCell) {
              break;
            }
          }
        }
        var $head = tr.doc.resolve(headCell.pos);
        return { $anchor, $head, indexes };
      };
    };
    var getSelectionRangeInRow = function getSelectionRangeInRow2(rowIndex) {
      return function(tr) {
        var startIndex = rowIndex;
        var endIndex = rowIndex;
        var _loop4 = function _loop42(i2) {
          var cells = getCellsInRow(i2)(tr.selection);
          cells.forEach(function(cell) {
            var maybeEndIndex = cell.node.attrs.rowspan + i2 - 1;
            if (maybeEndIndex >= startIndex) {
              startIndex = i2;
            }
            if (maybeEndIndex > endIndex) {
              endIndex = maybeEndIndex;
            }
          });
        };
        for (var i = rowIndex; i >= 0; i--) {
          _loop4(i);
        }
        var _loop5 = function _loop52(i2) {
          var cells = getCellsInRow(i2)(tr.selection);
          cells.forEach(function(cell) {
            var maybeEndIndex = cell.node.attrs.rowspan + i2 - 1;
            if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex) {
              endIndex = maybeEndIndex;
            }
          });
        };
        for (var i = rowIndex; i <= endIndex; i++) {
          _loop5(i);
        }
        var indexes = [];
        for (var i = startIndex; i <= endIndex; i++) {
          var maybeCells = getCellsInRow(i)(tr.selection);
          if (maybeCells && maybeCells.length) {
            indexes.push(i);
          }
        }
        startIndex = indexes[0];
        endIndex = indexes[indexes.length - 1];
        var firstSelectedRowCells = getCellsInRow(startIndex)(tr.selection);
        var firstColumnCells = getCellsInColumn(0)(tr.selection);
        var $anchor = tr.doc.resolve(firstSelectedRowCells[firstSelectedRowCells.length - 1].pos);
        var headCell = void 0;
        for (var _i4 = endIndex; _i4 >= startIndex; _i4--) {
          var rowCells = getCellsInRow(_i4)(tr.selection);
          if (rowCells && rowCells.length) {
            for (var j = firstColumnCells.length - 1; j >= 0; j--) {
              if (firstColumnCells[j].pos === rowCells[0].pos) {
                headCell = rowCells[0];
                break;
              }
            }
            if (headCell) {
              break;
            }
          }
        }
        var $head = tr.doc.resolve(headCell.pos);
        return { $anchor, $head, indexes };
      };
    };
    exports.isNodeSelection = isNodeSelection;
    exports.canInsert = canInsert;
    exports.convertTableNodeToArrayOfRows = convertTableNodeToArrayOfRows;
    exports.convertArrayOfRowsToTableNode = convertArrayOfRowsToTableNode;
    exports.findParentNode = findParentNode;
    exports.findParentNodeClosestToPos = findParentNodeClosestToPos;
    exports.findParentDomRef = findParentDomRef;
    exports.hasParentNode = hasParentNode;
    exports.findParentNodeOfType = findParentNodeOfType;
    exports.findParentNodeOfTypeClosestToPos = findParentNodeOfTypeClosestToPos;
    exports.hasParentNodeOfType = hasParentNodeOfType;
    exports.findParentDomRefOfType = findParentDomRefOfType;
    exports.findSelectedNodeOfType = findSelectedNodeOfType;
    exports.findPositionOfNodeBefore = findPositionOfNodeBefore;
    exports.findDomRefAtPos = findDomRefAtPos;
    exports.flatten = flatten;
    exports.findChildren = findChildren;
    exports.findTextNodes = findTextNodes;
    exports.findInlineNodes = findInlineNodes;
    exports.findBlockNodes = findBlockNodes;
    exports.findChildrenByAttr = findChildrenByAttr;
    exports.findChildrenByType = findChildrenByType;
    exports.findChildrenByMark = findChildrenByMark;
    exports.contains = contains;
    exports.findTable = findTable;
    exports.isCellSelection = isCellSelection;
    exports.getSelectionRect = getSelectionRect;
    exports.isColumnSelected = isColumnSelected;
    exports.isRowSelected = isRowSelected;
    exports.isTableSelected = isTableSelected;
    exports.getCellsInColumn = getCellsInColumn;
    exports.getCellsInRow = getCellsInRow;
    exports.getCellsInTable = getCellsInTable;
    exports.selectColumn = selectColumn;
    exports.selectRow = selectRow;
    exports.selectTable = selectTable;
    exports.emptyCell = emptyCell;
    exports.addColumnAt = addColumnAt;
    exports.moveRow = moveRow;
    exports.moveColumn = moveColumn;
    exports.addRowAt = addRowAt;
    exports.cloneRowAt = cloneRowAt;
    exports.removeColumnAt = removeColumnAt;
    exports.removeRowAt = removeRowAt;
    exports.removeTable = removeTable;
    exports.removeSelectedColumns = removeSelectedColumns;
    exports.removeSelectedRows = removeSelectedRows;
    exports.removeColumnClosestToPos = removeColumnClosestToPos;
    exports.removeRowClosestToPos = removeRowClosestToPos;
    exports.forEachCellInColumn = forEachCellInColumn;
    exports.forEachCellInRow = forEachCellInRow;
    exports.setCellAttrs = setCellAttrs;
    exports.createTable = createTable;
    exports.findCellClosestToPos = findCellClosestToPos;
    exports.findCellRectClosestToPos = findCellRectClosestToPos;
    exports.getSelectionRangeInColumn = getSelectionRangeInColumn;
    exports.getSelectionRangeInRow = getSelectionRangeInRow;
    exports.removeParentNodeOfType = removeParentNodeOfType;
    exports.replaceParentNodeOfType = replaceParentNodeOfType;
    exports.removeSelectedNode = removeSelectedNode;
    exports.replaceSelectedNode = replaceSelectedNode;
    exports.setTextSelection = setTextSelection;
    exports.safeInsert = safeInsert;
    exports.setParentNodeMarkup = setParentNodeMarkup;
    exports.selectParentNodeOfType = selectParentNodeOfType;
    exports.removeNodeBefore = removeNodeBefore;
  }
});

// dep:prosemirror-utils
var prosemirror_utils_default = require_dist();
export {
  prosemirror_utils_default as default
};
//# sourceMappingURL=prosemirror-utils.js.map
