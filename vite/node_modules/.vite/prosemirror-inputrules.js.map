{
  "version": 3,
  "sources": ["../../../node_modules/prosemirror-inputrules/src/inputrules.js", "../../../node_modules/prosemirror-inputrules/src/rules.js", "../../../node_modules/prosemirror-inputrules/src/rulebuilders.js"],
  "sourcesContent": ["import {Plugin} from \"prosemirror-state\"\n\n// ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\nexport class InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) \u2192 ?Transaction>)\n  // Create an input rule. The rule applies when the user typed\n  // something and the text directly in front of the cursor matches\n  // `match`, which should end with `$`.\n  //\n  // The `handler` can be a string, in which case the matched text, or\n  // the first matched group in the regexp, is replaced by that\n  // string.\n  //\n  // Or a it can be a function, which will be called with the match\n  // array produced by\n  // [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  // as well as the start and end of the matched range, and which can\n  // return a [transaction](#state.Transaction) that describes the\n  // rule's effect, or null to indicate the input was not handled.\n  constructor(match, handler) {\n    this.match = match\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler\n  }\n}\n\nfunction stringHandler(string) {\n  return function(state, match, start, end) {\n    let insert = string\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1])\n      insert += match[0].slice(offset + match[1].length)\n      start += offset\n      let cutOff = start - end\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert\n        start = end\n      }\n    }\n    return state.tr.insertText(insert, start, end)\n  }\n}\n\nconst MAX_MATCH = 500\n\n// :: (config: {rules: [InputRule]}) \u2192 Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\nexport function inputRules({rules}) {\n  let plugin = new Plugin({\n    state: {\n      init() { return null },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this)\n        if (stored) return stored\n        return tr.selectionSet || tr.docChanged ? null : prev\n      }\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin)\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            let {$cursor} = view.state.selection\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin)\n          })\n        }\n      }\n    },\n\n    isInputRules: true\n  })\n  return plugin\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false\n  let state = view.state, $from = state.doc.resolve(from)\n  if ($from.parent.type.spec.code) return false\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n                                            null, \"\\ufffc\") + text\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore)\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)\n    if (!tr) continue\n    view.dispatch(tr.setMeta(plugin, {transform: tr, from, to, text}))\n    return true\n  }\n  return false\n}\n\n// :: (EditorState, ?(Transaction)) \u2192 bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\nexport function undoInputRule(state, dispatch) {\n  let plugins = state.plugins\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i], undoable\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr, toUndo = undoable.transform\n        for (let j = toUndo.steps.length - 1; j >= 0; j--)\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        if (undoable.text) {\n          let marks = tr.doc.resolve(undoable.from).marks()\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n        dispatch(tr)\n      }\n      return true\n    }\n  }\n  return false\n}\n", "import {InputRule} from \"./inputrules\"\n\n// :: InputRule Converts double dashes to an emdash.\nexport const emDash = new InputRule(/--$/, \"\u2014\")\n// :: InputRule Converts three dots to an ellipsis character.\nexport const ellipsis = new InputRule(/\\.\\.\\.$/, \"\u2026\")\n// :: InputRule \u201CSmart\u201D opening double quotes.\nexport const openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"\u201C\")\n// :: InputRule \u201CSmart\u201D closing double quotes.\nexport const closeDoubleQuote = new InputRule(/\"$/, \"\u201D\")\n// :: InputRule \u201CSmart\u201D opening single quotes.\nexport const openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"\u2018\")\n// :: InputRule \u201CSmart\u201D closing single quotes.\nexport const closeSingleQuote = new InputRule(/'$/, \"\u2019\")\n\n// :: [InputRule] Smart-quote related input rules.\nexport const smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]\n", "import {InputRule} from \"./inputrules\"\nimport {findWrapping, canJoin} from \"prosemirror-transform\"\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) \u2192 ?Object>, ?([string], Node) \u2192 bool) \u2192 InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\nexport function wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    let tr = state.tr.delete(start, end)\n    let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return null\n    tr.wrap(range, wrapping)\n    let before = tr.doc.resolve(start - 1).nodeBefore\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n        (!joinPredicate || joinPredicate(match, before)))\n      tr.join(start - 1)\n    return tr\n  })\n}\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) \u2192 ?Object>) \u2192 InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\nexport function textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let $start = state.doc.resolve(start)\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null\n    return state.tr\n      .delete(start, end)\n      .setBlockType(start, start, nodeType, attrs)\n  })\n}\n"],
  "mappings": "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",
  "names": []
}
